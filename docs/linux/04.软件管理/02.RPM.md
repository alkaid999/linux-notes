---
title: RPM
sidebarPrefix: <i class='iconfont icon-RPM'> </i>
---

RPM Package Manager (RPM) 是一个强大的软件包管理系统，它运行在 Red Hat Enterprise Linux (RHEL)、CentOS 和 Fedora 等 Linux 发行版上。RPM 使得用户能够分发、管理和更新软件包，为这些操作系统提供了一种高效的软件管理解决方案。与传统的存档文件分发软件相比，RPM 软件包管理系统带来了以下显著优势：

- RPM 以可独立安装、更新或删除的软件包形式管理软件，从而更轻松地维护操作系统
- RPM 简化了软件的分发，因为 RPM 软件包是独立的二进制文件，类似于压缩存档。这些软件包是为特定的操作系统和硬件架构构建的。RPM 包含诸如已编译的可执行文件和库等文件，这些文件在安装软件包时被放在文件系统上的适当路径下

使用 RPM，用户可以执行以下操作：

- 安装、升级和删除软件包
- 查询关于软件包的详细信息
- 验证软件包的完整性和校验和
- 从源代码构建软件包，并生成构建文档
- 使用 GNU Privacy Guard (GPG) 工具对软件包进行数字签名，确保软件的安全性和可信度
- 在 DNF 存储库中发布软件包，便于软件的共享和分发

RPM 提供了一种可靠和高效的方式来管理 Linux 系统中的软件包，它的集成和自动化功能减少了手动操作的复杂性，同时确保了软件的一致性和可靠性。

## 命名规则

RPM 包的命名遵循一套特定的规则，这些规则帮助用户识别包的名称、版本、发布号以及支持的架构。一个典型的 RPM 包命名格式如下：

```shell
Package Name-Version-Release.Architecture.rpm
```

以下是各个部分的详细说明：

- 包名（Package Name）：这是软件包的名称，如 httpd、nginx 等
- 版本号（Version）：表示软件的版本，通常格式为主版本号、次版本号、修订号等
- 发布号（Release）：表示该版本的软件包被发布或修订的次数，每次软件包更新、修复或重新编译后，这个数字会增加，以反映软件包的新版本。发布号中可能包含特定的发行版标识符，标识符指示软件包是为特定的 Linux 发行版构建的。例如，el9 表示 Red Hat Enterprise Linux 9 或兼容发行版
- 架构（Architecture）：表示软件包支持的硬件架构，如 x86_64、aarch64 等（对于不依赖特定硬件架构的软件包，使用 noarch 表示）
- 扩展名（.rpm）：表示这是一个 RPM 包

例如，`nginx-1.20.1-16.el9_4.1.x86_64.rpm` 这个包名可以这样解读：是一个适用于 64 位 x86 架构的 Nginx 软件包，版本为 1.20.1，已经发布了 16 次，并且是为 Red Hat Enterprise Linux 9 或兼容发行版构建的。

> [!NOTE]
> 此外，还有以 `src.rpm` 作为扩展名的 RPM 包，这表明是源代码包，需要安装生成源码，然后对其编译并生成 `rpm` 格式的包，最后才能使用 `rpm` 命令进行安装。

| 架构名称           | 位宽 | 指令集类型 | 应用常见                                           | 备注                                                                                                                                                     |
| ------------------ | ---- | ---------- | -------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `x86_64` / `amd64` | 64位 | CISC       | 主流桌面 PC、数据中心服务器、云服务器              | 最初由 AMD 设计命名为 `AMD64`，后被 Intel 采纳并改称 `x86_64`，二者完全兼容；向下兼容 32 位 x86 架构，支持 AVX 等扩展指令集，是桌面 / 服务器端 64 位主流 |
| `i386`             | 32位 | CISC       | 早期桌面 PC、服务器，老旧工业设备、legacy 系统     | 名称源自 Intel 80386 处理器，泛指 32 位 x86 家族（含 i486、Pentium 等）；支持 16 位实模式兼容旧设备，最大寻址 4GB，主流系统已逐步停止维护                |
| `aarch64`          | 64位 | RISC       | 移动端、嵌入式设备、苹果 Mac、ARM 服务器、边缘计算 | 即 ARMv8-A 架构的 64 位执行状态，Linux 标识为 aarch64，macOS 标识为 arm64（二者等效）；苹果 M1/M2/M3 芯片基于此架构，部分 CPU 兼容 32 位 ARMv7           |
| `arm`              | 32位 | RISC       | 低端嵌入式设备、早期智能手机、单片机、老旧路由器   | 泛指 ARMv7 架构（分 `armhf` 硬件浮点、`armel` 软件浮点变体）；低功耗特性显著，最大寻址 4GB，不兼容 64 位 `aarch64`，广泛用于电池供电设备                 |

*有些软件包名中称架构为 `noarch`，这是表示该软件包不依赖于特定的硬件架构，而是与架构无关的软件包。这意味着无论用户的系统是 32 位还是 64 位，都可以安装和运行该软件包。*

---

补充说明

> [!TIP] 指令集类型
> 指令集类型是指 CPU 所采用的指令集架构（Instruction Set Architecture, ISA）在设计理念上的分类，主要反映其指令的复杂度、执行方式和硬件实现哲学。目前主流分为两大类型：
>
> - CISC（Complex Instruction Set Computer）：复杂指令集计算机，指令数量多，指令长度变长，指令执行时间长，功耗高。典型代表是 x86 架构的处理器
> - RISC（Reduced Instruction Set Computer）：精简指令集计算机，指令数量少，指令长度短，指令执行时间短，功耗低。典型代表是 ARM 架构的处理器

---

> [!TIP] 位宽
> 位宽是计算机体系结构中的一个基础概念，指的是处理器一次能处理的二进制数据的最大位数，通常以位（bit）为单位。它直接反映了 CPU 的数据处理能力和寻址能力。可以把位宽想象成 CPU 的车道宽度：
>
> - 32 位（i386）：像一条 32 车道的高速公路，一次最多运送 32 个 0/1 数据
> - 64 位（x86_64 / aarch64）：像一条 64 车道的高速公路，一次能处理更多数据，效率更高

## rpm 语法

`rpm` 命令是 Red Hat Package Manager（RPM）软件包的管理工具，它被广泛用于基于 RPM 的 Linux 发行版，如 Red Hat Enterprise Linux、CentOS、Fedora 和 OpenSUSE 等。RPM 是一种软件包格式，它允许用户安装、卸载、升级、查询和验证软件包。

```shell
rpm [OPTION]… [Package]…
```

:::: field-group
::: field name="OPTION" type="常用选项" optional
查询 / 验证软件包选项：

- `-a`：查询或验证所有已安装的软件包
- `-f`：用于查询拥有特定已安装文件的软件包
- `-p`：查询或验证一个软件包文件
- `-q`：查询已安装的软件包信息
- `-V`：验证已安装软件包的文件完整性

查询文件选项：

- `-c`：只显示与已安装软件包相关的配置文件
- `-d`：只显示与已安装软件包相关的文档文件
- `-L`：只显示与已安装软件包相关的许可文件
- `-A`：只显示与已安装软件包相关的构件文件

查询选项（与 `-q` 一起使用）:

- `-l`：列出软件包中的文件
- `-s`：显示列出文件的状态

验证选项：

- `--nofiledigest`：不验证文件的摘要
- `--nofiles`：不验证软件包中的文件

安装 / 升级 / 移除选项：

- `-i`：安装软件包
- `-U`：升级软件包，如果软件包已安装，则更新它
- `-F`：如果软件包已安装，则更新它，否则不安装
- `-e`：移除（卸载）软件包
- `--allfiles`：安装所有文件，包括可能会跳过的配置文件
- `--nodeps`：不验证软件包依赖
- `--noscripts`：不执行软件包脚本

通用选项：

- `-v`：提供更详细的输出
- `-h`：显示进度条
- `--quiet`：提供较少的详细输出
- `--help`：显示帮助信息

高级选项：

- `-D`：定义宏
- `-E`：打印宏的展开
- `-r`：指定根目录
- `--dbpath`：指定数据库路径
- `--noplugins`：不启用任何插件
- `--nosignature`：不验证软件包签名
:::
::: field name="Package" type="软件包" required
需要相应操作的一个或多个软件包文件（通常是 `.rpm` 文件）
:::
::::

### RPM 包安装

RPM 软件包的安装可以使用程序 `rpm` 来完成，例如：

```shell
rpm -ivh package_name.rpm...
```

在安装 RPM 软件包时，如果需要对安装过程进行特殊调整，可以使用以下选项：

- `-nodeps`：忽略依赖性。通常 RPM 会检查软件包的依赖关系，确保所有必需的底层软件已安装。使用此选项可跳过依赖检查，强制安装软件包。但请注意，忽略依赖可能导致软件无法正常运行，因此不推荐在生产环境中使用
- `--replacefiles`：替换已存在的文件。如果目标路径中已有同名文件，RPM 默认会拒绝安装。使用此选项可覆盖这些文件，继续完成安装
- `--replacepkgs`：重新安装已存在的软件包。若指定的软件包已经安装，RPM 通常会报错；使用此选项可忽略该错误并重新安装
- `--force`：强制安装。该选项等效于同时指定 `--replacefiles` 和 `--replacepkgs`，用于强制覆盖已存在文件和软件包
- `--test`：测试安装。模拟整个安装过程而不实际修改系统，可用于验证安装是否可能成功（包括依赖性检查等）
- `--prefix`：指定安装前缀路径。仅对“可重定位”的 RPM 包有效，用于将整个软件包安装到指定的新根目录下（例如 `--prefix=/opt` 将原本安装到 `/usr/local/myapp` 的内容改为 `/opt/myapp`）
- `--relocate`：细粒度重定位安装路径。允许为软件包中特定的目录路径单独指定新的目标位置（例如将 `/usr/bin` 重定位为 `/opt/bin`），适用于支持重定位的软件包
- `--allfiles`：强制安装所有文件。即使某些文件因被视为配置文件或出于安全原因通常被跳过，使用此选项也会将其一并安装
- `--noscripts`：跳过所有脚本执行。RPM 软件包可包含在安装、升级或卸载时运行的脚本（如 %pre、%post 等），使用此选项可禁止这些脚本的执行

[pkgs.org](https://pkgs.org/) 是一个跨发行版的 Linux 软件包搜索引擎与下载平台，旨在为用户提供简单、无过多弹窗的方式查找和下载最新 Linux 软件包。它聚合了多种 Linux 发行版的官方与镜像仓库信息，不维护仓库内容本身，仅提供搜索与链接服务。

- 获取 RPM 软件包

    例如，这里下载 btop 软件，下载地址 [https://dl.fedoraproject.org/pub/epel/10/Everything/x86_64/Packages/b/btop-1.4.5-1.el10_2.x86_64.rpm](https://dl.fedoraproject.org/pub/epel/10/Everything/x86_64/Packages/b/btop-1.4.5-1.el10_2.x86_64.rpm)。

    可以选择直接在服务器上通过 `wget` 或 `curl` 等工具下载，也可以先在本地下载后再通过远程终端工具上传至服务器。

    ```bash
    curl -O https://dl.fedoraproject.org/pub/epel/10/Everything/x86_64/Packages/b/btop-1.4.5-1.el10_2.x86_64.rpm
    ```

    ```console
    % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                    Dload  Upload   Total   Spent    Left  Speed
    100  595k  100  595k    0     0   287k      0  0:00:02  0:00:02 --:--:--  287k
    ```

    ```bash
    ls
    ```

    ```console
    btop-1.4.5-1.el10_2.x86_64.rpm
    ```

    > [!TIP] btop
    > btop 是一个开源的系统监控工具，它提供了一个直观且美观的界面来实时显示 Linux 系统中的 CPU、内存、磁盘、网络和进程的使用情况。它相当于是 Linux 系统中的高级替代品，类似于 Windows 中的任务管理器，但提供了更多的功能和更现代化的用户界面。

- 使用 `rpm` 命令安装

    使用终端或命令行界面，导航到包含 `.rpm` 文件的目录，然后使用 `rpm` 命令进行安装。

    ```bash
    rpm -ivh btop-1.4.5-1.el10_2.x86_64.rpm
    ```

    ```console
    warning: btop-1.4.5-1.el10_2.x86_64.rpm: Header V4 RSA/SHA256 Signature, key ID e37ed158: NOKEY
    Verifying...                          ################################# [100%]
    Preparing...                          ################################# [100%]
    Updating / installing...
    1:btop-1.4.5-1.el10_2              ################################# [100%]
    ```

    三个进度条是 RPM 安装过程中的 三个标准阶段，每个阶段有明确的作用：

  - `Verifying...`：验证软件包完整性。看到的 NOKEY 警告就发生在这个阶段：RPM 发现包有签名（key ID e37ed158），但系统没有导入对应的公钥，所以无法验证签名真伪，但仍继续安装（因为只是警告，不是错误）
  - `Preparing...`：准备安装。RPM 会检查软件包的依赖关系，确保所有必需的底层软件已安装。如果发现缺失的依赖，RPM 会提示用户安装缺失的软件包
  - `Updating / installing...`：更新 / 安装软件包。RPM 会将软件包中的文件复制到系统的适当位置，包括可执行文件、库文件、配置文件等。如果目标路径中已有同名文件，RPM 默认会拒绝安装。使用 `--replacefiles` 选项可覆盖这些文件，继续完成安装

- 使用 btop

    使用 `rpm` 命令安装软件时不需要像在 Windows 中那样手动指定安装目录，也不需要手动设置环境变量，因为软件包在设计时通常会包含其可执行文件、库文件、配置文件等所需的路径信息。

    可以直接在命令行执行 `btop`

    ```bash
    btop
    ```

    ![btop](/images/linux/06.png)

### RPM 包升级

RPM 包的升级可以通过 `rpm` 命令来完成：

```shell
rpm -Uvh package_name.rpm
```

- `-U`: 用于更新已安装的软件包或安装新软件包

```shell
rpm -Fvh package_name.rpm
```

- `-F`: 仅升级那些已经安装在系统上的软件包。如果指定的软件包没有安装，RPM 不会安装它，只有当软件包已经安装，并且提供了一个更新的版本时，RPM 才会执行升级操作。

### RPM 包卸载

RPM 包的卸载可以通过 `rpm` 命令来完成：

```shell
rpm -e package_name
```

- `-e`: 表示卸载

需要注意，RPM 软件包的卸载要考虑包之间的依赖性。在 Linux 系统中，软件包之间可能存在依赖关系。这意味着一个软件包可能依赖于另一个或多个软件包才能正常工作。这种依赖关系确保了软件的各个组件能够协同工作，提供所需的功能。

> [!WARNING]
> 如果其他软件包依赖于想要卸载的软件包，那么在卸载之前，需要决定如何处理这些依赖关系。如果强制卸载，可能会导致依赖它的软件包无法正常工作。除了直接依赖外，还可能存在间接依赖。例如，软件包 A 依赖于软件包 B，而软件包 B 又依赖于想要卸载的软件包。在这种情况下，卸载操作可能会影响到软件包 A 和 B。

在卸载软件包时，系统会尝试解决依赖性问题。如果系统能够自动解决依赖问题（例如，通过安装替代的软件包或移除依赖的软件包），那么卸载操作可以顺利进行。否则，系统会提示依赖性问题，并阻止卸载。

在某些情况下，可能需要卸载一个软件包，即使它被其他软件包依赖。这时，可以使用 `--nodeps` 选项来强制卸载软件包，但这可能会导致依赖它的软件包出现问题。所以在卸载软件包之前，可以使用 `rpm -qR` 命令来检查软件包的依赖关系。这可以了解哪些软件包依赖于想要卸载的软件包。

例如，查看一个 httpd 软件包所需的依赖（httpd 默认系统没有安装的）：

```bash
rpm -qR httpd
```

```console
/bin/sh
config(httpd) = 2.4.57-11.el9_4.1
httpd-core = 0:2.4.57-11.el9_4.1
libbrotlienc.so.1()(64bit)
libc.so.6()(64bit)
libc.so.6(GLIBC_2.2.5)(64bit)
libc.so.6(GLIBC_2.4)(64bit)
libsystemd.so.0()(64bit)
libsystemd.so.0(LIBSYSTEMD_209)(64bit)
rpmlib(CompressedFileNames) <= 3.0.4-1
rpmlib(FileDigests) <= 4.6.0-1
rpmlib(PayloadFilesHavePrefix) <= 4.0-1
rpmlib(PayloadIsZstd) <= 5.4.18-1
rtld(GNU_HASH)
system-logos-httpd
systemd-units
```

- `config(httpd) = 2.4.57-11.el9_4.1` 和 `httpd-core = 0:2.4.57-11.el9_4.1` 表示 httpd 软件包自身的配置和核心组件的版本
- `libbrotlienc.so.1()(64bit)` 表示需要 libbrotlienc 库的版本 1 的 64 位版本
- `libc.so.6()(64bit)` 和 `libc.so.6(GLIBC_2.2.5)(64bit)` 以及 `libc.so.6(GLIBC_2.4)(64bit)` 表示需要 C 标准库（libc）的版本 6 的 64 位版本，并且这个版本需要支持 GLIBC 版本 2.2.5 和 2.4
- `libsystemd.so.0()(64bit)` 和 `libsystemd.so.0(LIBSYSTEMD_209)(64bit)` 表示需要 libsystemd 库的版本 0 的 64 位版本，且该版本需要支持 LIBSYSTEMD_209 接口
- `rpmlib(CompressedFileNames) <= 3.0.4-1` 等条目是 RPM 软件包管理器的特定需求，它们要求系统中的 RPM 库版本至少为 3.0.4-1。
- `rtld(GNU_HASH)` 表示需要一个支持 GNU_HASH 的运行时链接器
- `system-logos-httpd` 和 `systemd-units` 表示依赖于特定的系统图标和 systemd 服务单元文件

这个列表中的每个条目都代表了 httpd 软件包在运行时或安装时可能需要的某个特定组件的特定版本。如果系统中缺少这些依赖，或者版本不兼容，那么 httpd 可能无法正确安装或运行。

当使用 `rpm -e` 卸载 httpd 软件包的时候会出现报错：

```bash
rpm -e httpd
```

```console
error: Failed dependencies:
        httpd >= 2.4.51-7 is needed by (installed) mod_http2-2.0.26-2.el9_4.x86_64
```

这个错误信息表明尝试从系统中卸载 httpd 软件包时遇到了依赖性问题。具体来说，有一个已经安装的软件包 `mod_http2-2.0.26-2.el9_4.x86_64` 依赖于 httpd 软件包，并且需要的是版本 2.4.51-7 或更高版本的 httpd。

由于系统中安装的 httpd 版本是 `2.4.57-11.el9_4.1`，它满足了 mod_http2 所需的最低版本要求，但是 `rpm` 命令不允许卸载 httpd，因为这样做会破坏 mod_http2 的依赖性，导致它无法正常工作。

要解决这个问题，可以选择下面几个选项：

- 不卸载 `httpd`：如果 `httpd` 对于系统的其他部分不是必需的，那么可以保留它
- 卸载 `mod_http2`：如果 `mod_http2` 不是必需的，可以先卸载它，然后再尝试卸载 `httpd`

    ```bash
    rpm -e mod_http2
    ```

- 强制卸载：如果确定要卸载 `httpd` 并且愿意承担由此可能引起的系统不稳定或其他问题，可以使用 `--nodeps` 选项来强制卸载，但这是不推荐的：

    ```bash
    rpm -e --nodeps httpd
    ```

    在处理依赖性问题时，一定要谨慎，确保了解每个步骤可能带来的后果。

- 使用包管理器：推荐使用 `yum` 或 `dnf` 包管理器，它们可以更好地处理依赖关系。例如，使用以下命令：

    ```bash
    dnf -y remove httpd
    ```

> [!TIP] 依赖性
> 在 Linux 系统中，软件包依赖性（Dependency）是指一个软件包在安装、升级或运行时所需要的其他软件包或库文件。依赖性的存在是为了确保软件能够正常编译、安装和执行。这些依赖确保了软件能够顺利运行，因为它们提供了必要的代码和资源。如果没有这些依赖，软件可能无法正常工作，就像缺少了一些关键部分的拼图无法完整一样。

### RPM 包查询

`rpm` 命令还可用来对 RPM 软件包做查询操作。以下是一些常用的查询操作：

- 查询软件包是否已安装

    使用 `rpm -q` 命令可以检查指定的软件包是否已在系统中安装。如果已安装，它会显示软件包的版本和发布信息：

    ```bash
    rpm -q btop
    ```

    ```console
    btop-1.3.2-1.el9.x86_64
    ```

    注意，`-q` 选项后面的参数是软件包的名称，通常只需要软件包的基础名称（name 字段）即可。

- 查询系统中所有已安装的软件包

    通过 `rpm -qa` 命令可以列出系统中所有已安装的 RPM 软件包。这个列表通常包括软件包的名称、版本、发布号和架构：

    ```bash
    rpm -qa
    ```

    ```console
    libgcc-11.4.1-3.el9.x86_64
    linux-firmware-whence-20240219-143.el9.noarch
    crypto-policies-20240202-1.git283706d.el9.noarch
    tzdata-2024a-1.el9.noarch
    linux-firmware-20240219-143.el9.noarch
    rocky-gpg-keys-9.4-1.5.el9.noarch
    rocky-release-9.4-1.5.el9.noarch
    ……
    ```

- 查看软件包的详细信息

    使用 `rpm -qi` 命令可以查看已安装软件包的详细信息，包括包的名称、版本、描述、构建日期、包大小、许可证、供应商和相关文档的位置等：

    ```bash
    rpm -qi btop
    ```

    ```console
    Name        : btop
    Version     : 1.3.2
    Release     : 1.el9
    Architecture: x86_64
    Install Date: Fri Oct 11 10:08:49 2024
    Group       : Unspecified
    Size        : 1667047
    License     : Apache-2.0 and MIT and Public Domain
    Signature   : RSA/SHA256, Tue Feb 13 11:39:49 2024, Key ID 8a3872bf3228467c
    Source RPM  : btop-1.3.2-1.el9.src.rpm
    Build Date  : Tue Feb 13 11:24:16 2024
    Build Host  : buildvm-x86-10.iad2.fedoraproject.org
    Packager    : Fedora Project
    Vendor      : Fedora Project
    URL         : https://github.com/aristocratos/btop
    Bug URL     : https://bugz.fedoraproject.org/btop
    Summary     : Modern and colorful command line resource monitor that shows usage and stats
    Description :
    Resource monitor that shows usage and stats for processor,
    memory, disks, network and processes.

    C++ version and continuation of bashtop and bpytop.
    ```

- 查询软件包的文件列表

    `rpm -ql` 命令可以列出一个已安装软件包的所有文件及其路径：

    ```bash
    rpm -ql btop
    ```

    ```console
    /usr/bin/btop
    /usr/lib/.build-id
    /usr/lib/.build-id/8e
    /usr/lib/.build-id/8e/bf501d14b42232438380565c64bc8c269a8faa
    /usr/share/applications/btop.desktop
    /usr/share/btop
    /usr/share/btop/themes
    /usr/share/btop/themes/HotPurpleTrafficLight.theme
    /usr/share/btop/themes/adapta.theme
    /usr/share/btop/themes/adwaita.theme
    /usr/share/btop/themes/ayu.theme
    /usr/share/btop/themes/dracula.theme
    /usr/share/btop/themes/dusklight.theme
    /usr/share/btop/themes/elementarish.theme
    /usr/share/btop/themes/everforest-dark-hard.theme
    /usr/share/btop/themes/everforest-dark-medium.theme
    /usr/share/btop/themes/flat-remix-light.theme
    /usr/share/btop/themes/flat-remix.theme
    /usr/share/btop/themes/greyscale.theme
    /usr/share/btop/themes/gruvbox_dark.theme
    /usr/share/btop/themes/gruvbox_dark_v2.theme
    /usr/share/btop/themes/gruvbox_material_dark.theme
    /usr/share/btop/themes/horizon.theme
    /usr/share/btop/themes/kyli0x.theme
    /usr/share/btop/themes/matcha-dark-sea.theme
    /usr/share/btop/themes/monokai.theme
    /usr/share/btop/themes/night-owl.theme
    /usr/share/btop/themes/nord.theme
    /usr/share/btop/themes/onedark.theme
    /usr/share/btop/themes/paper.theme
    /usr/share/btop/themes/solarized_dark.theme
    /usr/share/btop/themes/solarized_light.theme
    /usr/share/btop/themes/tokyo-night.theme
    /usr/share/btop/themes/tokyo-storm.theme
    /usr/share/btop/themes/tomorrow-night.theme
    /usr/share/btop/themes/whiteout.theme
    /usr/share/doc/btop
    /usr/share/doc/btop/CHANGELOG.md
    /usr/share/doc/btop/README.md
    /usr/share/icons/hicolor/48x48/apps/btop.png
    /usr/share/icons/hicolor/scalable/apps/btop.svg
    /usr/share/licenses/btop
    /usr/share/licenses/btop/LICENSE
    ```

    同时，`rpm` 命令 `-p` 选项（表示查询未安装的软件包信息，是 package 的首字母。）还可以查询未安装软件包中包含的所有文件以及打算安装的路径。注意，由于软件包还未安装，因此需要使用「绝对路径+包全名」的方式才能确定包。

- 查询某系统文件具体属于哪个 RPM 包：

    如果知道系统中某个文件的路径，可以使用 `rpm -qf` 命令来查询该文件属于哪个 RPM 包：

    ```bash
    rpm -qf /usr/share/doc/sed
    ```

    ```console
    sed-4.8-9.el9.x86_64
    ```

- 查询软件包的文档文件

    `rpm -qd` 命令可以列出一个已安装软件包的所有文档文件：

    ```bash
    rpm -qd btop
    ```

    ```console
    /usr/share/doc/btop/CHANGELOG.md
    /usr/share/doc/btop/README.md
    ```

- 查询软件包的依赖关系：

    `rpm -qR` 命令可以显示一个已安装软件包的所有依赖关系：

    ```bash
    rpm -qR btop
    ```

    ```console
    hicolor-icon-theme
    libc.so.6()(64bit)
    libc.so.6(GLIBC_2.14)(64bit)
    libc.so.6(GLIBC_2.2.5)(64bit)
    libc.so.6(GLIBC_2.24)(64bit)
    libc.so.6(GLIBC_2.3)(64bit)
    libc.so.6(GLIBC_2.3.4)(64bit)
    libc.so.6(GLIBC_2.32)(64bit)
    libc.so.6(GLIBC_2.34)(64bit)
    libc.so.6(GLIBC_2.4)(64bit)
    libgcc_s.so.1()(64bit)
    libgcc_s.so.1(GCC_3.0)(64bit)
    libgcc_s.so.1(GCC_3.3.1)(64bit)
    libm.so.6()(64bit)
    libm.so.6(GLIBC_2.2.5)(64bit)
    libstdc++.so.6()(64bit)
    libstdc++.so.6(CXXABI_1.3)(64bit)
    libstdc++.so.6(CXXABI_1.3.11)(64bit)
    libstdc++.so.6(CXXABI_1.3.13)(64bit)
    libstdc++.so.6(CXXABI_1.3.2)(64bit)
    libstdc++.so.6(CXXABI_1.3.3)(64bit)
    libstdc++.so.6(CXXABI_1.3.5)(64bit)
    libstdc++.so.6(CXXABI_1.3.9)(64bit)
    libstdc++.so.6(GLIBCXX_3.4)(64bit)
    libstdc++.so.6(GLIBCXX_3.4.11)(64bit)
    libstdc++.so.6(GLIBCXX_3.4.14)(64bit)
    libstdc++.so.6(GLIBCXX_3.4.15)(64bit)
    libstdc++.so.6(GLIBCXX_3.4.18)(64bit)
    libstdc++.so.6(GLIBCXX_3.4.19)(64bit)
    libstdc++.so.6(GLIBCXX_3.4.20)(64bit)
    libstdc++.so.6(GLIBCXX_3.4.21)(64bit)
    libstdc++.so.6(GLIBCXX_3.4.22)(64bit)
    libstdc++.so.6(GLIBCXX_3.4.26)(64bit)
    libstdc++.so.6(GLIBCXX_3.4.29)(64bit)
    libstdc++.so.6(GLIBCXX_3.4.5)(64bit)
    libstdc++.so.6(GLIBCXX_3.4.9)(64bit)
    rpmlib(CompressedFileNames) <= 3.0.4-1
    rpmlib(FileDigests) <= 4.6.0-1
    rpmlib(PayloadFilesHavePrefix) <= 4.0-1
    rpmlib(PayloadIsZstd) <= 5.4.18-1
    rtld(GNU_HASH)
    ```

    同样，在此命令的基础上增加 `-p` 选项，即可实现查找未安装软件包的依赖性。

## RPM 包验证

RPM 包验证是使用 RPM 工具来检查已安装的 RPM 软件包的完整性和真实性的过程。这通常涉及到验证软件包的签名和校验文件的完整性：

- RPM 包校验：其实就是将已安装文件和 `/var/lib/rpm/` 目录下的数据库内容进行比较，确定文件内容是否被修改
- RPM 包数字证书校验：用来校验 RPM 包本身是否被修改

### RPM 包校验

`rpm -V` 命令用于校验系统中已安装的 RPM 包的文件是否被修改或损坏。这个命令会将文件的当前状态与 RPM 数据库中的记录进行比较。如果文件未被修改，命令将不显示任何内容；如果文件被修改，它会显示一个状态码，指示文件的哪些属性被更改了。

例如，可以使用选项 `-Va` 表示校验系统中已安装的所有软件包：

```bash
rpm -Va 
```

```console
S.5....T.  c /etc/environment
.M.......  c /boot/grub2/grub.cfg
S.5....T.  c /root/.bashrc
```

RPM 的校验码（也称为状态码或验证信息）总共由 9 个字符组成，每个字符都代表文件的某个特定属性是否与 RPM 数据库中的记录匹配。下面是每个字符代表的含义：

1. `S`：文件大小（Size）是否改变
2. `M`：文件模式（Mode），包括文件类型和权限（例如读、写、执行权限）是否改变
3. `5`：文件的 MD5 校验和（MD5）是否改变，这通常表示文件内容是否被修改
4. `D`：设备文件的主要和次要号码（Device major/minor numbers）是否改变，这通常与字符设备或块设备文件相关
5. `L`：文件的链接（Link），即 readlink(2) 路径是否改变，这通常与符号链接有关
6. `U`：文件的所有者（User）是否改变
7. `G`：文件所属的组（Group）是否改变
8. `T`：文件的修改时间（Time）是否改变
9. `P`：文件的容量（i 节点的区块使用情况）是否改变

如果某个属性自 RPM 包安装后未发生变化，则相应的位置会显示一个点（`.`），表示该属性通过校验。如果属性发生变化，或者文件被修改过，则相应的状态码字符会显示出来。此外，如果文件是配置文件或文档文件等特殊类型的文件，状态码后面还可能跟有额外的字符来表示文件类型：

- `c`：配置文件（Configuration file）
- `d`：普通文档（Documentation）
- `g`：鬼文件（Ghost file），这类文件通常不应该被该 RPM 包所包含
- `l`：授权文件（License file）
- `r`：描述文件（Readme file）

这些标识符帮助用户了解文件的类型，特别是在配置文件被修改时，通常表示用户或系统管理员对系统进行了定制。而像文档文件、许可证文件和自述文件这类的文件，虽然不是程序的核心部分，但它们包含重要的信息，比如使用说明、版权信息等。

如果校验 btop 软件包中所有的安装文件是否被修改，可执行如下命令：

```shell
[root@localhost -]# rpm -V btop
```

可以看到，执行后无任何提示信息，表明所有用 btop 软件包安装的文件均未改动过，还和从原软件包安装的文件一样。

接下来尝试对 btop 的 README.md 文件进行修改，使用 `echo` 命令将字符串 `hello,btop` 追加到 `/usr/share/doc/btop/README.md` 文件的末尾：

```bash
echo "hello,btop" >> /usr/share/doc/btop/README.md
```

> [!TIP] README 文件
> README 文件通常是项目或软件包的自述文件，用于向用户介绍项目或软件的基本信息。它不仅帮助新用户快速了解项目，而且还为潜在的贡献者提供了如何参与项目的指导。

```bash
rpm -V btop
```

```console
S.5....T.  d /usr/share/doc/btop/README.md
```

可以看到命令的输出显示了 `/usr/share/doc/btop/README.md` 文件的状态，由于之前使用了 `echo "hello,btop" >> /usr/share/doc/btop/README.md` 命令向 README.md 文件追加了内容，这解释了为什么文件的大小和 MD5 校验和会发生变化。同时，因为文件被修改，其修改时间也相应地发生了变化。

> [!TIP]
> 并非所有对文件做修改的行为都是恶意的。通常情况下，对配置文件做修改是正常的，比如说配置 Nginx 就要修改其配置文件，而如果验证信息提示对二进制文件做了修改，这就需要小心，除非是自己故意修改的。

### RPM 数字证书验证

RPM 数字证书验证是一种用来确保 RPM 软件包在传输或存储过程中未被篡改，并且确认软件包来源可靠性的安全机制。数字证书，也称为数字签名，由软件开发商或分发者提供，通常包含了开发商的公钥信息。

当在系统中安装一个带有数字签名的 RPM 软件包时，RPM 工具会使用开发商提供的公钥来验证软件包的数字签名。如果数字签名有效，这意味着软件包自签名以来未被修改，并且可以被信任的源所验证。如果数字签名无效或软件包被篡改，验证将失败，系统会警告该软件包不可信。

例如，下载 Nginx 的 RPM 包和公钥，并验证软件包的完整性和来源。

::: steps

1. 下载 Nginx 的 RPM 包

    使用 `wget` 或 `curl` 下载 NGINX RPM 包，这里下载版本是 1.26.2：

    ```bash
    curl -O http://nginx.org/packages/rhel/9/x86_64/RPMS/nginx-1.26.2-1.el9.ngx.x86_64.rpm
    ```

    使用 `rpm -qi` 命令查看该 Nginx RPM 包，可以看到一段告警：

    ```bash
    rpm -pqi nginx-1.26.2-1.el9.ngx.x86_64.rpm 
    ```

    ```console
    warning: nginx-1.26.2-1.el9.ngx.x86_64.rpm: Header V4 RSA/SHA256 Signature, key ID 7bd9bf62: NOKEY
    Name        : nginx
    ……
    ```

    这个警告提示 NOKEY 表示在验证 RPM 包的签名时，系统找不到对应的 GPG 公钥。具体来说，它说明：
    - `Header V4 RSA/SHA256 Signature`：包的签名算法类
    - `key ID 7bd9bf62`：这是用来签名该包的公钥的唯一标识符

    这时使用 `rpm -K` 命令进行验证：

    ```bash
    rpm -K nginx-1.26.2-1.el9.ngx.x86_64.rpm
    ```

    ```console
    nginx-1.26.2-1.el9.ngx.x86_64.rpm: digests SIGNATURES NOT OK
    ```

    这个消息表明 RPM 包的签名验证失败，可能是因为缺少公钥、包被篡改或下载不完整。

2. 下载 Nginx 公钥，并且导入

    可以访问 Nginx 的官网下载：

    ```bash
    curl -O https://nginx.org/keys/nginx_signing.key
    ```

    导入下载的公钥：

    ```bash
    rpm --import nginx_signing.key
    ```

    导入完成后，可以使用 `rpm -qa gpg-pubkey` 命令可以查看系统中已导入的 GPG 公钥：

    ```bash
    rpm -qa gpg-pubkey
    ```

    ```console
    gpg-pubkey-b49f6b46-66572c16
    gpg-pubkey-7bd9bf62-4e4e3262
    gpg-pubkey-8d88a2b3-66573b5c
    ```

    这些公钥用于验证 RPM 包的签名，确保软件的安全性。每个公钥都有一个唯一的标识符，表示不同的发布者或源。看到的输出表明已经成功导入了这些公钥。

    > [!NOTE]
    > nginx_signing.key 是 Nginx 发布者提供的 GPG 公钥文件，用于验证 Nginx RPM 包的数字签名。通过这个公钥，用户可以确保下载的软件包未被篡改且来自可信的发布者。
    >
    > Nginx 的公钥通常可以验证所有版本的 Nginx RPM 包。公钥是用于验证该发布者（Nginx）的所有软件包签名的，因此导入一次后，系统可以用同一个公钥验证未来发布的所有版本。
    >
    > 如果 Nginx 发布了新的公钥（例如，在安全问题或密钥更换时），可能需要更新公钥。

3. 验证

    最后可以再次使用 `rpm -K` 命令验证下载的 RPM 包：

    ```bash
    rpm -K nginx-1.26.2-1.el9.ngx.x86_64.rpm
    ```

    ```console
    nginx-1.26.2-1.el9.ngx.x86_64.rpm: digests signatures OK
    ```

    这个输出表示 RPM 包的签名验证成功，数字签名是有效的，且摘要信息（如 SHA256 哈希）也匹配。表明包在传输过程中没有被篡改，并且来源可信。
:::

> [!TIP] NGINX
> NGINX 是一个高性能的开源 web 服务器，通常用于处理 HTTP 和反向代理请求，也可以作为邮件代理服务器。它以其高并发处理能力和低资源消耗而闻名，常被用于负载均衡、缓存和静态内容服务。许多大型网站和应用都采用 NGINX 来提升性能和可靠性。

## 提取 RPM 包

RPM 包本质上是一个归档文件，它不仅包含了软件的文件，还包含了关于软件的元数据和安装信息。这些元数据包括文件列表、依赖信息、配置文件、触发脚本、文档和许可证信息、版本信息以及数字签名等。

> [!NOTE]
> RPM 包在设计时选择了 `cpio` 作为其内部文件存储的格式，因此使用 `cpio` 工具来提取 RPM 包中的文件是最直接的方法。

### cpio 命令

`cpio` 是一个用于创建和提取归档文件的工具，它可以从归档文件中提取文件（或目录），也可以将文件（或目录）复制到归档文件中。它的名称来源于 copy in 和 copy out，指的是将文件复制到归档中（copy-in）以及从归档中复制出来（copy-out）。

当使用 `cpio` 命令进行数据备份或恢复时，需要注意以下几点：

- 备份时使用的路径类型会影响恢复位置。如果备份时采用绝对路径，那么恢复时文件会自动回到它们原来的绝对位置。若使用相对路径进行备份，文件则会相对于当前位置被恢复
- `cpio` 命令需要完整的目标文件或目录路径来执行备份或恢复操作。它不能自动识别要备份或恢复的文件，因此通常需要与 `find` 命令结合使用来指定这些路径
- 在恢复数据时，`cpio` 不会自动覆盖已存在的同名文件，也不会在目标位置创建新的目录结构。文件会被直接解压到当前目录中，而不会重建原有的目录层次

`cpio` 有三种主要模式：copy-out 模式、copy-in 模式和 copy-pass 模式。

```shell
cpio [OPTION...]
```

:::: field-group

::: field name="OPTION" type="常用选项" optional

主操作模式（必须且只能选一个）：

- `-o`：将文件打包为归档（创建归档）
- `-i`：从归档中提取文件（解压归档）
- `-p`：直接复制文件（不创建归档）

通用选项（适用于所有模式）：

- `-v`：显示处理的文件名（详细模式）
- `-V`：每处理一个文件输出一个 `.`（用于长任务进度提示）
- `-B`：设置 I/O 块大小为 5120 字节（默认 512），提升磁带/大文件性能
- `-C NUM`：自定义 I/O 块大小（单位：字节），比 `-B` 更灵活
- `-D DIR`：在执行前先 `cd DIR`，改变工作目录
  - `-i` 模式：归档内容解压到 `DIR` 下
  - `-o` 模式：从 `DIR` 读取文件列表
  - `-p` 模式：复制文件前切换到 `DIR`
- `--quiet`：禁止输出已复制 N 个块的统计信息
:::
::::

> [!NOTE]
> `cpio` 本身不处理路径，需配合 `find` 等命令生成文件列表。

#### copy-out 模式

在 copy-out 模式下，`cpio` 用于创建归档文件。它从标准输入读取文件列表，并将这些文件打包成一个归档文件，输出到标准输出或指定的文件。

```shell
cpio -o [OPTION]… < file-list > archive
```

:::: field-group

::: field name="OPTION" type="常用选项" optional

仅适用于 `-o`（创建归档）：

- `-H FORMAT`：指定归档格式。`newc`（推荐，SVR4 格式）、`crc`（带校验和）、`tar`兼容 tar）、`odc`（旧 ASCII 格式）、`bin`（默认 binary，不可移植）
- `-c`：使用 portable ASCII 格式（等价于 `-H newc`），跨平台兼容（x86/ARM/Linux/macOS）
- `-O FILE`：将归档直接写入 FILE（代替 stdout）
- `-A`：追加到已有归档（需配合 `-O` 或 `-F`）
- `-a`：读取文件后重置其访问时间（atime），避免因备份操作影响访问时间戳
- `-0`：从 stdin 读取 null 字符分隔的文件名（配合 `find -print0`，安全处理特殊字符文件名）
:::

::: field name="file-list" type="文件列表（标准输入）" required
由其他命令（如 `find`、`ls`）生成的文件路径列表，每行一个路径，通过管道或重定向传给 `cpio`。
:::
::: field name="archive" type="归档输出（标准输出）" required
生成的 `cpio` 归档数据，默认输出到标准输出，通常通过 `>` 重定向保存为文件或写入设备。
:::
::::

例如，将 `/etc` 下的所有普通文件都备份到 /opt/etc.cpio，使用以下命令：

```bash
find /etc -type f | cpio -ocvB > /opt/etc.cpio
```

```bash
ll -h /opt/etc.cpio
```

```console
-rw-r--r--. 1 root root 20M Oct 16 14:56 /opt/etc.cpio
```

#### copy-in 模式

在 copy-in 模式下，`cpio` 用于从归档文件中提取文件。它从标准输入读取归档文件，并根据需要提取文件到文件系统或列出归档内容。

```shell
cpio -i [OPTION...] [< archive]
```

:::: field-group
::: field name="OPTION" type="常用选项" optional

- `-d`：自动创建所需目录，若目标路径中的父目录不存在
- `-u`：无条件覆盖已存在的文件，跳过时间比较
- `-m`：保留原始文件的修改时间（`mtime`），否则默认使用当前时间
- `-t`：仅列出归档内容（不提取，常与 `-v` 组合为 `-tv`）
- `--no-absolute-filenames`：强制将绝对路径转为相对路径（如 `/etc/passwd` → `etc/passwd`），防止意外覆盖系统文件
- `-F FILE`：从指定 FILE 读取归档（代替 stdin）
:::
::: field name="archive" type="归档输入（标准输入）" required
cpio 归档数据，默认从标准输入读取，通常通过 `<` 重定向从文件或管道传入。也可用 `-F` 直接指定归档文件路径。
:::
::::

例如，使用 `cpio` 恢复之前备份的数据：

```bash
cpio -icduv < /opt/etc.cpio
```

注意，`cpio` 恢复的路径，如果 `cpio` 在打包备份的时候用的是绝对路径，那么在恢复的时候会自动恢复到这些绝对路径下，这个就会将备份文件全部还原到 `/etc` 路径下对应的目录中。

如果希望在使用 `cpio` 恢复文件时指定一个不同的路径，而不是文件最初备份时的路径，可以使用 `--no-absolute-filenames` 选项来忽略绝对路径信息：

```bash
cpio -icduv --no-absolute-filenames < /opt/etc.cpio
```

```bash
ll -d etc/
```

```console
drwxr-xr-x. 46 root root 4096 Oct 16 15:17 etc/
```

`cpio` 默认会将文件恢复到当前工作目录，如果想要提取时指定目录，还可以使用 `-D` 选项：

```bash
cpio -icduv --no-absolute-filenames -D /tmp < /opt/etc.cpio
```

```console
ll -d /tmp/etc/
```

```console
drwxr-xr-x. 46 root root 4096 Oct 16 15:21 /tmp/etc/
```

#### copy-pass 模式

在 copy-pass 模式下，`cpio` 用于将文件从一个目录复制到另一个目录，这个过程不需要创建实际的归档文件。它从标准输入读取文件列表，并根据指定的目标目录进行复制。

```shell
cpio -p [OPTION...] DESTINATION-DIRECTORY < file-list
```

:::: field-group
::: field name="OPTION" type="常用选项" optional

- `-d`：自动创建目标路径中缺失的父目录（类似 `mkdir -p`）
- `-m`：保留源文件的修改时间（`mtime`），否则新文件使用当前时间
- `-u`：无条件覆盖目标文件
- `-l`：硬链接代替复制，若源和目标在同一文件系统，节省空间和时间
- `-a`：读取源文件后重置其访问时间（`atime`）
- `-0`：从 stdin 读取 null 分隔的文件名（配合 `find -print0`，安全处理含空格 / 换行的文件名）
:::
::: field name="DESTINATION-DIRECTORY" type="目标目录" required
必须作为 `cpio -p` 命令的最后一个非选项参数提供。所有从标准输入读取的文件，将按其相对路径结构复制到此目录下。
:::
::: field name="file-list" type="文件列表（标准输入）" required
由 `find`、`ls` 等命令生成的文件路径列表，必须是相对于当前工作目录的路径。强烈建议使用 `find ... -print0` 并配合 `-0` 选项，避免文件名含特殊字符导致错误。
:::
::::

例如，将 `/boot/` 复制到 `/root/` 目录：

```bash
find /boot/ -print0 | cpio -p0 /root/
```

```console
380176 blocks
```

```bash
ls boot/
```

```console
System.map-5.14.0-427.13.1.el9_4.x86_64                  initramfs-5.14.0-427.13.1.el9_4.x86_64kdump.img
config-5.14.0-427.13.1.el9_4.x86_64                      loader
efi                                                      symvers-5.14.0-427.13.1.el9_4.x86_64.gz
grub2                                                    vmlinuz-0-rescue-7ef6458d2b22468d9101dcc8ef8dd496
initramfs-0-rescue-7ef6458d2b22468d9101dcc8ef8dd496.img  vmlinuz-5.14.0-427.13.1.el9_4.x86_64
initramfs-5.14.0-427.13.1.el9_4.x86_64.img
```

### 提取 RPM 包中指定文件

在服务器运维过程中，如果遇到系统文件被错误地修改或删除的情况，可以通过 `cpio` 命令来恢复这些文件。利用 `cpio` 命令提取包内的文件，并将其恢复到原来的位置。这个过程不仅能够挽救因误操作而丢失的文件，还能快速恢复服务，减少系统的停机时间。

`rpm2cpio` 是一个非常有用的命令行工具，它的作用是将 RPM 包转换为 cpio 格式的数据流。这种转换可以更容易地提取 RPM 包中的文件，而无需安装整个软件包。

例如，如果不小心删除了 `cp` 命令，可以使用 `rpm2cpio` 和 `cpio` 来从相应的 RPM 包中提取这个文件：

::: steps

1. 查看相关命令的 RPM 包

    可以使用 `rpm -qf` 命令来找出哪个 RPM 包提供了 `cp` 命令：

    ```bash
    rpm -qf /bin/cp
    ```

    ```console
    coreutils-8.32-35.el9.x86_64
    ```

    可以看到 `cp` 命令是由 coreutils-8.32-35.el9.x86_64 RPM 包提供的。然后删除删除 `cp` 命令，模拟故障：

    ```bash
    rm -rf /bin/cp 
    ```

    ```bash
    cp 
    ```

    ```console
    -bash: cp: command not found
    ```

2. 下载相关 RPM 包

    ```shell
    curl -O https://dl.rockylinux.org/pub/rocky/9/BaseOS/x86_64/os/Packages/c/coreutils-8.32-35.el9.x86_64.rpm
    ```

    ```bash
    ll
    ```

    ```console
    -rw-r--r--.  1 root root 1171953 Oct 18 10:39 coreutils-8.32-35.el9.x86_64.rpm
    ```

3. 提取 RPM 包中相关命令

    首先将 RPM 包转换为 CPIO 归档格式，并将转换后的 CPIO 文件内容输出到标准输出，然后通过重定向操作符 `>` 将其保存到名为 coreutils.cpio 的文件中：

    ```bash
    rpm2cpio coreutils-8.32-35.el9.x86_64.rpm > coreutils.cpio
    ```

    ```bash
    ll coreutils*
    ```

    ```console
    -rw-r--r--. 1 root root 1171953 Oct 18 10:39 coreutils-8.32-35.el9.x86_64.rpm
    -rw-r--r--. 1 root root 6023640 Oct 18 11:25 coreutils.cpio
    ```

    然后将之前创建的 CPIO 归档文件 coreutils.cpio 中提取出指定的 ./usr/bin/cp 文件：

    ```bash
    [root@localhost ~]# cpio -idv ./usr/bin/cp < coreutils.cpio
    ```

    ```bash
    ll
    ```

    ```console
    total 7032
    -rw-r--r--. 1 root root 1171953 Oct 18 10:39 coreutils-8.32-35.el9.x86_64.rpm
    -rw-r--r--. 1 root root 6023640 Oct 18 11:25 coreutils.cpio
    drwxr-xr-x. 3 root root      17 Oct 20 19:09 usr
    ```

    ```bash
    ll -al usr/bin/cp 
    ```

    ```console
    -rwxr-xr-x. 1 root root 152744 Oct 20 19:09 usr/bin/cp
    ```

4. 恢复命令

    将 `cp` 命令移动到 `/bin` 或 `/usr/bin` 目录下：

    ```bash
    mv usr/bin/cp /usr/bin/
    ```

    最后可以通过运行 `cp` 命令的 `--version` 或 `--help` 选项来获取更多关于该命令的信息，这可以确认它确实是从 CPIO 归档中提取的 `cp` 命令。

    ```bash
    cp
    ```

    ```console
    cp: missing file operand
    ```

    ```bash
    cp --version
    ```

    ```console
    cp (GNU coreutils) 8.32
    Copyright (C) 2020 Free Software Foundation, Inc.
    License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.
    This is free software: you are free to change and redistribute it.
    There is NO WARRANTY, to the extent permitted by law.

    Written by Torbjorn Granlund, David MacKenzie, and Jim Meyering.
    ```

:::

## SRPM

SRPM 包，全称为 Source RPM，即源代码 RPM 包。它是一种包含了软件源代码的 RPM 包，允许用户从源代码开始编译软件，而不是直接安装已经编译好的二进制文件。使用 SRPM 包，用户可以根据自己的需要对源代码进行修改，然后重新编译生成 RPM 包，这样可以更好地控制软件的行为和适应特定的系统环境。

SRPM 包的主要特点包括：

- 包含源代码：SRPM 包中包含的是软件的源代码，而不是编译后的二进制文件
- 可定制性强：用户可以修改源代码或配置文件，以适应特定的需求或系统环境
- 编译生成 RPM 包：通过编译 SRPM 包，可以生成对应的 RPM 二进制包，然后使用 RPM 包管理器进行安装

SRPM 包的命名与 RPM 包基本类似，唯一区别在于 SRPM 包多了 `src`，也可以通过 `pkgs.org` 网站进行获取相关源码。

使用 SRPM 包安装软件的方式主要有两种：

- **利用 `rpmbuild` 命令**：可以直接使用 SRPM 包进行安装，也可以先将 SRPM 包编译成 RPM 包，然后再使用生成的 RPM 包进行安装
- **利用 `*.spec` 文件**：可以通过解压 SRPM 包获取 `*.spec` 文件，进而编译 SRPM 包生成 RPM 包，最后使用该 RPM 包进行安装

尽管它们包含源代码，但它们仍然遵循 RPM 包管理的规则，包括依赖性管理。在构建 SRPM 中的软件之前，需要确保系统上安装了所有必需的构建依赖。这些依赖包括编译器、库文件、开发工具和其他可能需要的包，以便成功编译和构建软件。

### rpm-build 工具集

`rpm-build` 是 RHEL/Fedora/EL 系系统中，提供 `rpmbuild` 核心命令及配套脚本、配置的软件包，它实现了 RPM 打包的全流程（解析 spec 文件、执行构建阶段、生成 RPM 包），是 RPM 打包的基础依赖，没有它就无法完成任何 RPM 包的构建 / 重建。

`rpm-build` 的核心价值是执行 RPM 打包的流水线，具体做这几件事：

1. 解析 spec 文件：读取你写的 spec 打包说明书（定义包名、版本、依赖、安装路径等）
2. 执行构建阶段：按 spec 文件的定义，依次执行 `%prep`（准备源码）、`%build`（编译）、`%install`（安装到临时目录）等阶段
3. 生成 RPM 包：将构建好的文件打包成二进制 RPM（`.rpm`）或源码 RPM（`.src.rpm`）
4. 校验规范：检查打包过程是否符合 RPM 规范（比如文件权限、依赖声明是否合法）

`rpm-build` 的核心命令是 `rpmbuild`：

```shell
rpmbuild [OPTION]… [ <specfile> | <tarball> | <source package> ]
```

:::: field-group
::: field name="OPTION" type="常用选项" optional

主构建动作：

- 基于 `<specfile>`
  - `-bp`：执行到 `%prep`（解压源码 + 打补丁）
  - `-bc`：执行到 `%build`（完成编译）
  - `-bi`：执行到 `%install`（完成安装到 BUILDROOT）
  - `-bb`：仅构建二进制 RPM 包（`.rpm`）
  - `-bs`：仅构建源码 RPM 包（`.src.rpm`）
  - `-ba`：同时构建源码 + 二进制 RPM 包（完整构建）
  - `-bl`：验证 `%files` 列表（检查哪些文件会被打包）
  - `-bd`：检查构建依赖（不实际构建）
- 基于 `<tarball>`
  - `-tp`, `-tc`, `-ti`, `-tb`, `-ts`, `-ta` 等功能同上，但输入是 `.tarball` 而非 `.spec`
- 基于 `<source package>`
  - `-rp`, `-rc`, `-ri`, `-rb`, `-rs`, `-ra` 等功能同上，但输入是 `.src.rpm` 而非 `.spec`

构建行为控制：

- `--buildroot=DIRECTORY`：覆盖默认 `BUILDROOT` 路径（调试时常用）
- `--clean`：构建完成后自动清理 `BUILD` 目录
- `--noclean`：跳过 `%clean` 阶段（保留中间文件，便于调试）
- `--nobuild`：不执行任何构建阶段（仅解析 `spec`）
- `--nodeps`：跳过构建依赖检查（危险！仅用于测试）
- `--short-circuit`：直通到指定阶段（仅与 `-bc` / `-bi` 配合使用）

输出与调试：

- `-v`：详细输出（显示每一步命令）
- `--quiet`：减少输出（静默模式）
- `--showrc`：显示最终生效的 rpm 配置和宏定义（排查环境问题）
- `--trace`：跟踪宏展开过程（高级调试）
- `--nodebuginfo`：不生成 debuginfo 包（加快构建）

路径与环境：

- `-r`, `--root=ROOT`：将 ROOT 作为系统根目录（用于 chroot 环境）
- `--dbpath=DIRECTORY`：指定 RPM 数据库路径
- `--macros=<FILE>`：加载自定义宏文件（替代默认 `/etc/rpm/macros.*`）
:::

::: field name="specfile" type="Spec 文件" optional
`.spec` 描述文件
:::

::: field name="tarball" type="源码压缩包" optional
源码压缩包
:::

::: field name="source package" type="源码 RPM 包" optional
`.src.rpm` 源码包
:::

::::

了解 `rpmbuild` 的基本用法后，可以通过一个实际场景来加深理解，如何从官方源码包重建一个二进制 RPM 软件包。

还是以 btop 工具为例，演示如何使用：

::: steps

1. 下载 `rpm-build` 工具集和 `openssl`

    ```bash
    dnf install -y rpm-build openssl openssl-devel
    ```

    - `openssl`：核心主包，包含 `openssl` 命令、运行时库（libssl.so.3/libcrypto.so.3），提供 `rpmbuild` 所需的 3.4.0 + 版本符号。
    - `openssl-devel`：开发库包，包含编译源码所需的头文件（如 openssl/ssl.h）和静态库，是重建源码包的必备依赖。

    > [!WARNING]
    > 必须确保 openssl 版本为 3.4.0 +，否则会报错，并会导致系统崩溃！

2. 准备 btop 软件的源码包：

    ```bash
    curl -O https://dl.fedoraproject.org/pub/epel/10/Everything/source/tree/Packages/b/btop-1.4.5-1.el10_2.src.rpm
    ```

    ```console
    % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                    Dload  Upload   Total   Spent    Left  Speed
    100 1344k  100 1344k    0     0   135k      0  0:00:09  0:00:09 --:--:--  140k
    ```

    ```bash
    ls
    ```

    ```console
    btop-1.4.5-1.el10_2.src.rpm
    ```

3. 构建二进制 RPM 包

    ```bash
    rpmbuild -rb btop-1.4.5-1.el10_2.src.rpm
    ```

    ```console
    Installing btop-1.4.5-1.el10_2.src.rpm
    warning: btop-1.4.5-1.el10_2.src.rpm: Header V4 RSA/SHA256 Signature, key ID e37ed158: NOKEY
    setting SOURCE_DATE_EPOCH=1758931200
    error: Failed build dependencies:
            desktop-file-utils is needed by btop-1.4.5-1.el10.x86_64
            gcc-c++ is needed by btop-1.4.5-1.el10.x86_64
            lowdown is needed by btop-1.4.5-1.el10.x86_64
            make is needed by btop-1.4.5-1.el10.x86_64

    RPM build warnings:
        btop-1.4.5-1.el10_2.src.rpm: Header V4 RSA/SHA256 Signature, key ID e37ed158: NOKEY
    ```

    这是是执行 `rpmbuild` 时的典型反馈，来逐行解释这些信息，并说明哪些需要处理、哪些可以忽略：

    错误 `error: Failed build dependencies`：因为 `btop.spec` 文件中声明了构建时需要这些软件包，但系统没有安装它们，因此 `rpmbuild` 拒绝继续编译。

    告警 `warning: btop-1.4.5-1.el10_2.src.rpm: Header V4 RSA/SHA256 Signature, key ID e37ed158: NOKEY`：这个 `.src.rpm` 是由 Fedora/EPEL 官方用 GPG 密钥签名的，但系统尚未导入该公钥，所以 RPM 无法验证签名真伪，但不影响构建功能，即使没有密钥，只要文件完整，`rpmbuild` 仍能正常工作。

4. 处理依赖问题

    由于构建时依赖缺少，运行以下命令自动安装所有缺失的构建依赖：

    ```bash
    dnf -y builddep btop-1.4.5-1.el10_2.src.rpm
    ```

    ```console
    Last metadata expiration check: 0:12:39 ago on Wed 14 Jan 2026 11:04:29 AM CST.
    No matching package to install: 'lowdown'
    Not all dependencies satisfied
    Error: Some packages could not be found.
    ```

    提示 `lowdown` 包找不到的问题，核心原因是：`lowdown` 不在 Rocky 10 的 BaseOS 官方源中，而是归属于 EPEL 10 源，可以添加 EPEL 源来解决：

    ```bash
    dnf install -y epel-release
    ```

    然后再次执行 `dnf builddep` 命令，安装所有缺失的构建依赖：

    ```bash
    dnf -y builddep btop-1.4.5-1.el10_2.src.rpm
    ```

5. 再次执行构建

    ```bash
    rpmbuild -rb btop-1.4.5-1.el10_2.src.rpm
    ```

    ```console
    Installing btop-1.4.5-1.el10_2.src.rpm
    setting SOURCE_DATE_EPOCH=1758931200
    Executing(%prep): /bin/sh -e /var/tmp/rpm-tmp.lfod6F
    + umask 022
    + cd /root/rpmbuild/BUILD
    + cd /root/rpmbuild/BUILD
    + rm -rf btop-1.4.5
    + /usr/lib/rpm/rpmuncompress -x /root/rpmbuild/SOURCES/btop-1.4.5.tar.gz
    + STATUS=0
    + '[' 0 -ne 0 ']'
    + cd btop-1.4.5
    + rm -rf /root/rpmbuild/BUILD/btop-1.4.5-SPECPARTS
    + /usr/bin/mkdir -p /root/rpmbuild/BUILD/btop-1.4.5-SPECPARTS
    + /usr/bin/chmod -Rf a+rX,u+w,g-w,o-w .
    + RPM_EC=0
    ++ jobs -p
    + exit 0
    Executing(%build): /bin/sh -e /var/tmp/rpm-tmp.dxuU2s
    + umask 022
    + cd /root/rpmbuild/BUILD
    ……
    + umask 022
    + cd /root/rpmbuild/BUILD
    + cd btop-1.4.5
    + /usr/bin/rm -rf /root/rpmbuild/BUILDROOT/btop-1.4.5-1.el10.x86_64
    + RPM_EC=0
    ++ jobs -p
    + exit 0
    Executing(rmbuild): /bin/sh -e /var/tmp/rpm-tmp.m5iWXz
    + umask 022
    + cd /root/rpmbuild/BUILD
    + rm -rf /root/rpmbuild/BUILD/btop-1.4.5-SPECPARTS
    + rm -rf btop-1.4.5 btop-1.4.5.gemspec
    + RPM_EC=0
    ++ jobs -p
    + exit 0
    ```

:::

可以看到终端显示了命令执行的过程，其中包括了多个阶段：

1. 准备阶段（`%prep`）：这个阶段涉及到解压源码包，准备构建环境
2. 构建阶段（`%build`）：在这个阶段，使用编译器（如 `gcc` 或 `g++`）编译源代码。这里使用了 `make` 命令来构建软件，并且输出了编译进度
3. 安装阶段（`%install`）：编译完成后，`make install` 命令被用来将编译好的程序安装到指定的目录（这里是 `$RPM_BUILD_ROOT` 目录）
4. 文档阶段（`%doc`）：如果软件包包含文档，这个阶段会将文档文件复制到构建目录中
5. 许可阶段（`%license`）：这个阶段会处理软件包的许可证文件，确保它们被包含在最终的 RPM 包中
6. 清理阶段（`%clean`）：构建完成后，这个阶段会清理构建环境，删除临时文件
7. 生成 RPM 包：最后，`rpmbuild` 命令会生成二进制 RPM 包，包括软件包本身、调试信息包（如果生成了调试信息）和源代码包（如果有的话）

在 `rpmbuild` 的上下文中，每个阶段（如 `%prep`、`%build`、`%install` 等）都是一个单独的脚本，这些脚本在成功执行后会以 `exit 0` 结束，表示该阶段顺利完成。SRPM 包编译完成后，会在当前目录生成 `rpmbuild` 目录，整个编译过程生成的文件（软件包）都存在这里：

```bash
ls rpmbuild/
```

```console
BUILD  BUILDROOT  RPMS  SOURCES  SPECS  SRPMS
```

| 目录        | 作用                                                                                                                                                                                              |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `BUILD`     | 这个目录用于存放软件包构建过程中产生的文件。当 `rpmbuild` 命令执行时，它会在这个目录下进行编译和构建操作。所有的构建活动，包括编译源代码，都发生在这个目录中                                      |
| `BUILDROOT` | 构建完成后，`rpmbuild` 会将最终的安装文件放置在此目录下的一个子目录中。这个目录模拟了系统的根目录，用于存放构建过程中安装的文件和目录，以便生成 RPM 包时使用                                      |
| `RPMS`      | 这个目录用于存放最终生成的二进制 RPM 软件包。这些软件包是为特定架构构建的，比如 x86_64 或 i686。如果系统是 x86_64 架构，那么会在这个目录下找到 x86_64 子目录，里面包含了为该架构构建的所有 RPM 包 |
| `SOURCES`   | 这个目录包含了用于构建软件包的源代码文件。当执行 `rpmbuild` 命令时，源代码包（通常是 `.tar.gz` 文件）会被放置在这个目录下                                                                         |
| `SPECS`     | 这个目录包含了用于定义如何构建软件包的规格说明文件（`.spec` 文件）。这些文件包含了构建 RPM 包所需的所有信息，包括软件包的名称、版本、依赖关系、构建脚本等                                         |
| `SRPMS`     | 这个目录用于存放生成的源码 RPM 软件包。源码 RPM 包含了构建软件包所需的源代码和 `.spec` 文件。这些包可以被用来在其他系统上重新构建二进制 RPM 包                                                    |

```bash
ll rpmbuild/RPMS/x86_64/
```

```console
total 6344
-rw-r--r--. 1 root root  608988 Jan 14 11:47 btop-1.4.5-1.el10.x86_64.rpm
-rw-r--r--. 1 root root 5695434 Jan 14 11:47 btop-debuginfo-1.4.5-1.el10.x86_64.rpm
-rw-r--r--. 1 root root  187431 Jan 14 11:47 btop-debugsource-1.4.5-1.el10.x86_64.rpm
```

其中 debuginfo 和 debugsource 是两种特殊的软件包，它们在 RPM 包构建过程中生成，用于调试目的。

### mock 工具

`mock` 是 Fedora/RHEL/CentOS/EL 等 RPM 系 Linux 发行版官方推出的专属工具，专门用来隔离构建 RPM 软件包。可以把它理解成一个沙盒。

当需要打包 / 重建 RPM 时，`mock` 会先搭建一个和目标系统完全一致的、干净的迷你隔离系统有构建操作（安装依赖、编译、打包）都在这个沙盒里完成。构建结束后，沙盒可以直接销毁，宿主机的文件、库、配置完全不会被改动，最终只输出构建好的 RPM 包，从根本上避免破坏宿主机核心组件的风险。

```shell
mock [OPTION]… {OPERATION}
```

:::: field-group

::: field name="OPERATION" type="核心动作" required
作是 `mock` 的核心执行指令，决定 `mock` 要完成的核心任务，是命令中必须指定的核心部分：

- `--rebuild /path/to/srpm(s)`：以指定 SRPM 为输入，在隔离环境完成依赖安装、编译、打包，输出二进制 RPM 包
- `--buildsrpm`：基于 spec 文件和源码，构建生成 SRPM 源码包
- `--chain /path/to/srpm(s)`：按顺序链式构建多个有依赖关系的 SRPM 包
- `--init`：初始化干净的隔离构建环境，不执行构建操作
- `--clean`：彻底删除指定的隔离构建环境
- `--scrub=all`：清理指定隔离环境的所有内容（含环境本身和各类缓存）
- `--shell <cmd>`：交互式在隔离环境执行命令，无命令时默认进入 `/bin/sh` 终端
- `--chroot <cmd>`：非交互式在隔离环境执行指定命令
- `--installdeps {SRPM|RPM}`：仅解析并安装指定包的构建依赖，不执行构建
- `--install PACKAGE`：在隔离环境中安装指定软件包
- `--copyin path [..path] destination`：将宿主机文件 / 目录复制到隔离环境指定路径
- `--copyout path [..path] destination`：将隔离环境文件 / 目录复制到宿主机指定路径
- `--dnf-cmd arguments`：在隔离环境中执行 `dnf` 包管理命令
- `--list-chroots`：列出系统中所有可用的 `mock` 隔离环境配置文件名称及路径
:::

::: field name="OPTION" type="常用核心选项" optional

选项是对动作的辅助配置，调整执行行为、指定环境 / 路径 / 参数等，按功能分类：

- `-r CONFIG`：指定隔离环境的配置文件（核心选项，决定目标发行版 / 架构）
- `-n`：构建前不清理隔离环境，复用已有环境
- `--no-cleanup-after`：构建后不清理隔离环境，用于调试构建失败问题
- `--resultdir RESULTDIR`：指定构建产物（RPM、日志）的输出目录
- `-v`：启用详细输出模式，打印完整构建日志，便于排查问题
- `-D 'MACRO EXPR'`：定义 RPM 宏，临时覆盖 spec 中的宏配置
- `-a REPO`：为隔离环境添加额外 yum/dnf 仓库
- `--enablerepo [repo]`：启用隔离环境中的指定软件仓库
- `--disablerepo [repo]`：禁用隔离环境中的指定软件仓库
- `--isolation ISOLATION`：指定隔离级别，常用 nspawn（强隔离）或 simple（基础隔离）
- `--nocheck`：跳过 make check 阶段的测试用例，加快构建速度
:::
::::

`mock` 工具在 RHEL/EL/Fedora 系系统中，默认不在基础源里，而是存放在 EPEL 源里。如果要使用 `mock` 工具，必须先安装 EPEL 源：

```bash
dnf install -y epel-release
```

```bash
dnf install -y mock
```

> [!TIP]
> 如果使用 `mock` 工具就不需要在宿主机手动安装 `rpm-build`，它会在它的隔离构建环境中自动下载并安装 `rpm-build`（以及所有构建所需的依赖），这也是 mock “隔离构建” 的核心优势之一。

::: steps

1. 准备源码包

    再次使用 btop-1.4.5-1.el10_2.src.rpm 源码包作为示例：

    ```bash
    ls btop-1.4.5-1.el10_2.src.rpm
    ```

    ```console
    btop-1.4.5-1.el10_2.src.rpm
    ```

2. 确认可用的 mock 配置

    源码包为 `.el10_2` 版本（适配 RHEL/CentOS/Rocky 10.2 系统），需找到能复刻 el10 系列（主版本一致，小版本 10.0/10.2 兼容）环境的 `mock` 配置，确保构建出的二进制包适配目标操作系统。

    执行以下命令筛选出适配 Rocky 10 系列的配置，聚焦主版本（10）即可，无需严格匹配小版本（2）：

    ```bash
    mock --list-chroots | grep -E "rocky.*10"
    ```

    ```console
    INFO: mock.py version 6.6 starting (python version = 3.12.9, NVR = mock-6.6-1.el10_1), args: /usr/libexec/mock/mock --list-chroots
    Start(bootstrap): init plugins
    INFO: selinux enabled
    Finish(bootstrap): init plugins
    Start: init plugins
    INFO: selinux enabled
    Finish: init plugins
    INFO: Signal handler active
    Start: run
    <string>:5: SyntaxWarning: invalid escape sequence '\$'
    <string>:5: SyntaxWarning: invalid escape sequence '\$'
    <string>:5: SyntaxWarning: invalid escape sequence '\$'
    <string>:5: SyntaxWarning: invalid escape sequence '\$'
    <string>:5: SyntaxWarning: invalid escape sequence '\$'
    <string>:5: SyntaxWarning: invalid escape sequence '\$'
    rocky+epel-10-aarch64              Rocky Linux 10 + EPEL
    rocky+epel-10-ppc64le              Rocky Linux 10 + EPEL
    rocky+epel-10-s390x                Rocky Linux 10 + EPEL
    rocky+epel-10-x86_64               Rocky Linux 10 + EPEL
    rocky-10-aarch64                   Rocky Linux 10
    rocky-10-ppc64le                   Rocky Linux 10
    rocky-10-riscv64                   Rocky Linux 10
    rocky-10-s390x                     Rocky Linux 10
    rocky-10-x86_64                    Rocky Linux 10
    ```

    可以看到 `rocky-10-x86_64` 适配 x86_64 架构的 Rocky Linux 10 环境，完全兼容 el10_2 版本，但是推荐使用 `rocky+epel-10-x86_64`此配置，因为内置 EPEL 仓库，可解决构建依赖缺失问题。若需构建其他架构的包（如 aarch64），选择对应架构的 `rocky-10-xxx` 配置即可。

    输出中的 `SyntaxWarning: invalid escape sequence '\$'` 是 `mock` 配置文件的语法提示，不影响配置使用，可忽略。

    > [!NOTE]
    > 筛选 Rocky 10 的 `mock` 配置，本质是确认「mock 能否复刻出 Rocky 10 的环境来构建包」，最终目的是让打包后的二进制 RPM 能安装到 Rocky（目标操作系统）上，和执行命令的本机系统（哪怕是 CentOS 8）毫无关系。

3. 执行 mock 构建

    基于筛选出的 `rocky+epel-10-x86_64` 配置（复刻 Rocky 10 + EPEL 环境），在隔离的目标系统环境中完成 SRPM 包的编译、打包，生成适配 el10_2 x86_64 架构的二进制 RPM 包（全程与本机系统无关）。

    ```shell
    mock -r rocky+epel-10-x86_64 \
    --rebuild ~/btop-1.4.5-1.el10_2.src.rpm \   # 指定要构建的 SRPM 包
    -v \                                        # 启用详细输出，便于排查构建报错
    --resultdir ./btop-el10_2-build-result \    # 指定输出目录，存放构建产物（RPM、日志）
    --no-cleanup-after                          # 构建后不清理隔离环境，用于调试构建失败问题
    ```

:::

`mock` 执行命令后，会脱离本机系统完成以下操作（全程隔离）：

1. 初始化隔离环境：下载 Rocky 10 x86_64 基础系统文件，搭建与目标系统一致的纯净环境
2. 配置仓库：自动加载 Rocky 10 官方仓库 + EPEL 仓库（因选择 rocky+epel-10-x86_64 配置）
3. 安装构建依赖：解析 SRPM 包声明的依赖，从仓库安装编译 btop 所需的所有工具 / 库
4. 编译打包：解压 SRPM 源码，按 spec 文件规则编译，生成适配 el10_2 x86_64 的二进制 RPM
5. 输出产物：将二进制 RPM、构建日志等文件复制到 --resultdir 指定的目录，隔离环境保留（若加了 `--no-cleanup-after`）

命令执行完成后，在指定目录下生成以下文件：

```bash
ls btop-el10_2-build-result/
```

```console
btop-1.4.5-1.el10.src.rpm                 hw_info.log
btop-1.4.5-1.el10.x86_64.rpm              installed_pkgs.log
btop-debuginfo-1.4.5-1.el10.x86_64.rpm    root.log
btop-debugsource-1.4.5-1.el10.x86_64.rpm  state.log
build.log
```

`mock` 的隔离环境（chroot）默认存放在 `/var/lib/mock/` 目录下：

```bash
ls /var/lib/mock/
```

```console
rocky+epel-10-x86_64  rocky+epel-10-x86_64-bootstrap
```

`mock` 构建目标环境（如 rocky+epel-10-x86_64）时，不会直接在宿主机上搭建完整的 Rocky 10 环境，而是先创建一个极简的 bootstrap 环境，这个环境是搭建真正目标环境的「施工工具间」，仅包含最基础的系统工具（如 `dnf`、`rpm`、`bash`、`chroot` 等），用于执行下载目标系统文件、初始化 `chroot`、配置仓库等核心操作。

如果构建失败，想手动在隔离环境里排查问题（比如补装依赖、重新编译），进入后，终端提示符会变化，此时所有操作都在 Rocky 10 + EPEL 隔离环境中。执行以下命令进入交互式终端：

```bash
mock -r rocky+epel-10-x86_64 --shell
```

```console
<mock-chroot> sh-5.2#
```

`--no-cleanup-after` 会保留环境，成功后建议手动清理，避免占用磁盘空间。执行以下命令清理环境：

```bash
mock -r rocky+epel-10-x86_64 --clean
```

### .spec 文件

`.spec` 文件是 RPM 软件包管理系统中使用的一种规格说明文件，它详细描述了如何构建一个 RPM 软件包。这个文件包含了构建过程中所需的所有信息，包括软件包的名称、版本、依赖关系、源代码位置、构建脚本以及如何安装和卸载软件包等。

`.spec` 文件是构建 RPM 软件包的关键，它告诉 `rpmbuild` 工具如何构建、安装和测试软件包。开发者或系统管理员可以编辑 `.spec` 文件来定制软件包的构建过程。

`rpm -i` 命令通常用于安装 RPM 包，但是对于 SRPM 包，使用 `rpm -i` 命令实际上会将 SRPM 包解开，并将其中的源码和规格文件（`.spec`）放到当前目录下的 rpmbuild 目录中，而不会真正安装源码包。这个过程相当于解压 SRPM 包中的源码和规格文件，但并不是编译或安装软件本身。

```bash
rpm -i btop-1.3.2-1.el9.src.rpm
```

```console
warning: btop-1.3.2-1.el9.src.rpm: Header V4 RSA/SHA256 Signature, key ID 3228467c: NOKEY
warning: user mockbuild does not exist - using root
warning: group mock does not exist - using root
warning: user mockbuild does not exist - using root
warning: group mock does not exist - using root
```

```bash
ll rpmbuild/
```

```console
total 0
drwxr-xr-x. 2 root root 31 Oct 23 15:32 SOURCES
drwxr-xr-x. 2 root root 23 Oct 23 15:32 SPECS
```

和 `rpmbuild --rebuild` 命令不同，`rpm -i` 命令创建的 rpmbuild 目录中仅有 SOURCES 和 SPECS 两个子目录。其中，SOURCES 目录中放置的是源码，SPECS 目录中放置的是设置文件。

接下来使用 SPECS 目录中的设置文件生成 RPM 包：

```bash
rpmbuild -ba rpmbuild/SPECS/btop.spec
```

使用 `rpmbuild -ba` 命令会启动编译过程，该过程不仅会生成 RPM 二进制包，还会生成 SRPM 源码包。如果只希望生成二进制包，可以使用 `-bb` 选项。执行该命令后，将在当前目录下的 `rpmbuild/` 目录下创建多个子目录，包括 BUILD、RPMS、SOURCES、SPECS 和 SRPMS。其中，RPMS 目录用于存放生成的二进制 RPM 包，而 SRPMS 目录则用于存放源码 RPM 包。

## RPM 数据库

RPM 数据库是基于 RPM 包管理机制的 Linux 发行版（如 Rocky Linux、RHEL、CentOS）中核心的元数据管理系统，它记录了系统内所有通过 RPM 方式安装的软件包的完整生命周期信息，是 `rpm`、`yum`/`dnf` 等包管理工具实现查询、安装、升级、卸载、依赖校验的核心依赖。

RPM 数据库以结构化形式存储以下关键内容，支撑包管理工具的所有核心功能：

- 软件包元数据：包含包名、版本号、发布号（Release）、架构（x86_64/arm64 等）、安装时间、许可证协议、供应商、软件分组（如 System Environment/Base）、包描述等基础信息
- 安装文件清单：记录每个软件包安装的所有文件的绝对路径、权限、所有者、所属组、文件大小、时间戳，以及文件类型标记（如配置文件标记为 `%config`、文档标记为 `%doc`）
- 依赖关系数据：存储软件包的三类依赖。运行依赖（Requires），运行该软件必须满足的前置条件；提供能（Provides），该软件向系统提供的功能或库；冲突关系（Conflicts），与该软件无法共存的其他包
- 脚本与触发规则：记录软件包在安装（pre/post）、卸载（preun/postun）阶段自动执行的脚本，以及跨包的触发脚本（trigger）
- 数字签名与完整性校验数据：存储软件包的 GPG 签名信息、文件校验和（如 SHA256），用于验证包的来源合法性和文件完整性
- 配置文件宏信息：记录标记为 `%config` 的配置文件的原始状态、是否被修改等信息，支持 `rpm -V` 命令校验配置文件完整性

Rocky Linux 10 基于 RHEL 10 构建，对 RPM 数据库做了底层存储引擎和路径的双重调整，与旧版本（Rocky Linux 8/9 及更早）差异显著：

| 版本类型                       | 存储引擎           | 核心文件特征                                                  |
| ------------------------------ | ------------------ | ------------------------------------------------------------- |
| 旧版（Rocky Linux 8/9 及更早） | Berkeley DB（db4） | 多文件结构：Packages、Name、Requirename 等多个独立索引文件    |
| 新版（Rocky Linux 10）         | SQLite             | 单主文件结构：rpmdb.sqlite 为主库，搭配共享内存和日志辅助文件 |

新版将 RPM 数据库的实际存储路径迁移至 `/usr/lib/sysimage/rpm/`，同时保留 `/var/lib/rpm` 软链接（指向 `../../usr/lib/sysimage/rpm）`，确保旧脚本、旧命令无需修改即可兼容运行：

```bash
ll /var/lib/rpm
```

```console
lrwxrwxrwx. 1 root root 26 Jan 14 09:53 /var/lib/rpm -> ../../usr/lib/sysimage/rpm
```

```bash
ll /usr/lib/sysimage/rpm/
```

```console
total 32472
-rw-r--r--. 1 root root 33153024 Jan 15 12:56 rpmdb.sqlite
-rw-r--r--. 1 root root    98304 Jan 15 12:56 rpmdb.sqlite-shm
-rw-r--r--. 1 root root        0 Jan 15 12:56 rpmdb.sqlite-wal
```

| 文件名称           | 功能详解                                                                                                                                                                                                                               |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| rpmdb.sqlite       | RPM 数据库的 **核心主文件**，采用 SQLite 单文件数据库格式，聚合存储所有已安装包的元数据、文件列表、依赖关系等全部信息，是旧版多个 Berkeley DB 索引文件的功能合集。文件为二进制格式，不可直接编辑，需通过 `rpm` 命令或 sqlite3 工具读取 |
| rpmdb.sqlite-shm   | SQLite 的 **共享内存文件**，用于多进程并发访问数据库时的锁机制协调，避免读写冲突（如 rpm 和 dnf 同时操作数据库）。该文件为临时文件，系统正常关机时会自动清理，异常关机后残留不影响数据库可用性，rpm 命令会自动重建                     |
| `rpmdb.sqlite-wal` | SQLite 的 **预写日志文件**，实现数据库事务的原子性（保证 rpm 安装 / 卸载操作 “要么全部完成，要么全部回滚”）。该文件记录未同步到主库的临时操作，rpm 会定期将日志数据合并至 rpmdb.sqlite，无需手动干预                                   |

这些文件共同支持 RPM 数据库的运行，确保 RPM 包管理系统可以高效地查询和管理已安装的软件包。管理员通常不需要直接操作这些文件，因为 RPM 命令会自动处理数据库的维护工作。例如，当使用 `rpm` 命令安装或卸载软件包时，RPM 数据库会自动更新。

但是如果操作不当导致 RPM 数据库出现故障，例如：

- 系统异常中断：磁盘 I/O 错误、文件系统损坏、意外断电、强制关机等，会导致 rpmdb.sqlite 写入不完整，破坏数据库结构
- 手动篡改文件：绕过 `rpm` 命令直接删除 / 修改已安装文件，或手动编辑数据库文件，会导致数据库记录与实际文件系统状态不同步
- 升级流程中断：系统版本升级或大版本包升级过程中强制终止，会导致数据库处于半更新的不一致状态
- 权限或磁盘空间问题：`/usr/lib/sysimage/rpm/` 目录权限被篡改，或磁盘分区满导致数据库无法写入，会引发数据写入失败

`rpm --rebuilddb` 是最常用的修复手段，其核心作用是重建数据库的索引结构，而非重新生成完整的数据库数据。适用场景：数据库索引损坏（如查询缓慢、依赖校验报错），但主文件 rpmdb.sqlite 未丢失、未被严重破坏。

`rpm --initdb` 的作用是创建一个全新的空数据库，而非修复现有数据库。适用场景：`/usr/lib/sysimage/rpm/` 目录被完全删除，需要从零创建数据库。注意：空数据库创建后，系统内已安装包的记录会全部丢失，需结合其他手段恢复。

## RPM 包依赖性管理

RPM是 RHEL、Rocky Linux、CentOS 等基于 RPM 体系 Linux 发行版的核心包管理器，其强依赖性校验是保障系统稳定性的关键，但手动使用 rpm 命令安装包时，依赖性问题也成为最常见的挑战，尤其是安装 `gcc` 这类依赖链较长的工具时，该问题尤为突出。

例如，最小化安装的 Linux 服务器默认不会预装 `gcc` 编译工具，需手动安装。若直接使用 `rpm` 命令安装 `gcc` RPM 包，会触发明确的依赖性错误，具体操作与报错如下：

```bash
curl -O https://cdn-ubi.redhat.com/content/public/ubi/dist/ubi10/10/x86_64/appstream/os/Packages/g/gcc-14.3.1-2.1.el10.x86_64.rpm
```

```bash
rpm -ivh gcc-14.3.1-2.1.el10.x86_64.rpm
```

```console
warning: gcc-14.3.1-2.1.el10.x86_64.rpm: Header V4 RSA/SHA256 Signature, key ID fd431d51: NOKEY
error: Failed dependencies:
        cpp = 14.3.1-2.1.el10 is needed by gcc-14.3.1-2.1.el10.x86_64
        glibc-devel >= 2.2.90-12 is needed by gcc-14.3.1-2.1.el10.x86_64
        libgcc >= 14.3.1-2.1.el10 is needed by gcc-14.3.1-2.1.el10.x86_64
        libgomp = 14.3.1-2.1.el10 is needed by gcc-14.3.1-2.1.el10.x86_64
        libmpc.so.3()(64bit) is needed by gcc-14.3.1-2.1.el10.x86_64
        make is needed by gcc-14.3.1-2.1.el10.x86_64
```

- 签名警告说明：`Header V4 RSA/SHA256 Signature, key ID fd431d51: NOKEY` 仅表示系统未导入该 RPM 包的官方签名密钥，属于安全校验提示（不影响安装）

- 依赖错误核心解析：该错误表明安装 `gcc` 前需满足 6 个依赖条件，RPM 对依赖的版本约束规则清晰且严格：

    |版本约束符号|核心含义|示例|
    |-|-|-|
    |`=`|依赖包版本必须严格等于指定版本|`cpp = 14.3.1-2.1.el10`|
    |`>=`|依赖包版本大于或等于指定版本|`glibc-devel >= 2.2.90-12`|
    |`<=`|依赖包版本小于或等于指定版本|`openssl <= 3.0.1-1.el10`（示例）|
    |无符号|仅要求安装该包，不限制具体版本|make|

- 特殊依赖：`libmpc.so.3()(64bit)` 并非直接的包名依赖，而是 RPM 的能力依赖。RPM 不仅校验「是否安装某个包」，还会校验「系统是否提供某个具体的功能 / 文件 / 库」，其各部分含义如下：

    |表达式部分|具体含义|
    |-|-|
    |`libmpc`|共享库基础名称（多精度复数运算库，`gcc` 编译的核心依赖库）|
    |`.so`|Shared Object 缩写，即 Linux 动态共享库（类似 Windows 的 DLL 文件）|
    |`.3`|共享库主版本号（主版本号不一致会导致二进制不兼容，因此强制要求为 3）|
    |`()`|空括号表示依赖该库的「任意符号 / 功能」；若为 (`MPC_1.0`) 则指定具体符号版本|
    |`(64bit)`|指定依赖 64 位架构的库文件（32 位库会标注 `(32bit)`），避免架构不兼容|

    若需找到提供该能力的具体包，可执行以下命令：

    ```bash
    dnf provides 'libmpc.so.3()(64bit)'
    ```

    ```console
    Rocky Linux 10 - BaseOS                                95 kB/s | 7.2 MB     01:17    
    Rocky Linux 10 - AppStream                             70 kB/s | 8.3 MB     02:00    
    Rocky Linux 10 - Extras                                27 kB/s | 9.5 kB     00:00    
    libmpc-1.3.1-7.el10.x86_64 : C library for multiple precision complex arithmetic
    Repo        : appstream
    Matched from:
    Provide    : libmpc.so.3()(64bit)
    ```

---

RPM 包依赖关系的常见类型：

Linux 系统中 RPM 包的依赖关系主要分为三类，不同类型的解决方式差异显著。

树形依赖（线性依赖）：

- 核心特征：依赖关系呈层级链式结构，如 A 依赖 B、B 依赖 C、C 依赖 D（从上层到下层的层级依赖）
- 解决方法：从最底层依赖包开始，自下而上依次安装

环形依赖（循环依赖）：

- 核心特征：多个包形成闭环依赖，如 A 依赖 B、B 依赖 C、C 依赖 A，单独安装任一包都会触发依赖错误
- 解决方法：使用一条 `rpm` 命令同时安装所有闭环内的包，让 RPM 一次性解析并满足所有依赖

模块依赖（文件 / 库依赖）：

- 核心特征：包依赖其他包中的特定文件（如共享库、配置文件、可执行文件），而非整个包，`gcc` 依赖 `libmpc.so.3()(64bit)` 就属于此类
- 解决方法：
  1. 手动方式：通过 `dnf provides` 依赖表达式 或第三方网站（如 pkgs.org、rpmfind.net）查询包含该文件的包，下载并安装
  2. 自动方式：使用 DNF/YUM 自动解析并安装对应包

在实际使用中，优先使用 `dnf`/`yum` 而非原生 `rpm` 命令安装包，避免手动处理复杂依赖链，如果离线场景下，先用 `dnf download --resolve` 下载目标包及所有依赖，再离线安装。
