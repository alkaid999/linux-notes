---
title: 源码包
sidebarPrefix: <i class='iconfont icon-a-targztubiao'> </i>
---

源码包指的是包含了软件最原始的代码内容的压缩包，通常用于自行编译安装软件。这些源码包通常以 `.tar.gz` 或 `.tar.bz2` 为文件后缀，提供了软件的源代码，需要用户自行编译安装。源码包中一般包含有程序源代码文件、配置文件（如 configure）、安装使用说明（如 INSTALL、HOWTO、README）等。源码包的安装需要将源代码通过编译转换为计算机可以识别的机器语言，然后才可以安装。

## 编译安装准备

在 Linux 系统中，当从源代码包安装软件时，通常需要使用 GCC 编译器来编译那些用 C 语言编写的代码。除了编译器本身，可能还需要安装和配置一些其他的依赖库和工具，以确保编译过程能够顺利进行（例如 `g++` 等）。这些依赖项可能包括库文件、头文件、构建工具等，它们对于构建软件至关重要。因此，在开始编译之前，确保这些依赖项已经正确安装和配置，是成功编译和安装软件的关键步骤。

> [!TIP] GCC
> GCC 是 GNU 编译器集合（GNU Compiler Collection）的缩写，它是自由软件基金会（FSF）开发的一个编译器。GCC 最初是为 C 语言设计的，但后来扩展支持了多种编程语言，包括 `C++`、`Objective-C`、`Fortran`、`Ada`、`Go` 和 `D` 等。

除了安装编译器，还需要安装 `make` 编译命令。在 Linux 系统中，编译单个源代码文件（如 hello.c）确实相对简单，但编译一个包含多个源代码文件和复杂依赖关系的源码包则需要更自动化的工具。`make` 工具就是这样一个自动化构建工具，它通过读取名为 Makefile 的文件来理解项目中文件的依赖关系和编译顺序，从而自动化整个编译过程。

Makefile 中定义了如何编译源代码文件、链接生成可执行文件以及安装软件的步骤。使用 `make` 命令时，它会根据 Makefile 中的指令自动执行必要的编译和链接操作，极大地简化了从源码包编译软件的过程。因此，除了编译器，`make` 也是编译源码包时常用的一个工具。

所以，在编译安装软件之前，需要先安装 GCC 编译器和 Make 工具：

```shell
dnf -y install gcc make
```

## 编译安装步骤

源码编译安装步骤通常涉及以下环节：

1. **准备环境**：确保系统已安装必要的编译器（如 `gcc`）和构建工具（如 `make`）。安装所有必需的依赖库和工具，这些信息通常可以在软件的文档或 README 文件中找到
2. **获取源代码**：从官方网站或其他可信来源下载软件的源代码包。解压缩源代码包，通常使用 `tar`、`unzip` 等命令
3. **配置构建**：进入源代码目录。运行 `./configure` 脚本，它会自动检测系统环境并准备 Makefile。这一步可能需要指定一些参数，如安装路径等
4. **编译源代码**：运行 `make` 命令来编译源代码。这一步会根据 Makefile 中的指令编译源文件
5. 测试（可选）：运行 `make check` 或 `make test` 来执行软件自带的测试，确保编译后的程序按预期工作
6. **安装软件**：运行 `make install` 命令将编译好的程序安装到系统上
7. 清理构建文件（可选）：运行 make clean 来清理编译过程中产生的临时文件，释放空间
8. 配置系统（如果需要）：根据需要配置系统环境变量、启动脚本等，以确保软件能够正常运行

---

`./configure` 是 GNU Autotools（主要是 `autoconf` + `automake`）工具链生成的配置脚本，主要用于遵循 GNU 规范的开源软件（比如 Apache、Nginx、PHP 等经典软件）。

简单来说，`./configure` 的唯一核心目标是生成适配当前系统环境和用户需求的 Makefile 文件。

> [!NOTE] Makefile
> Makefile 是一份给 `make` 命令读取的纯文本编译规则清单，它把多文件项目的编译步骤、文件依赖关系都写清楚，核心作用是让 `make` 命令自动完成编译工作，还能通过对比文件时间戳实现增量编译，只重新编译修改过的文件，不用重复编译所有文件，它的规则格式很简单，就是目标：依赖文件，后接一行以 <kbd>Tab</kbd> 开头的执行命令，把它和源码放在同一目录，敲 `make` 就能自动编译生成程序，敲 `make clean` 则能自动清理编译产生的临时文件。

除了生成 Makefile 文件，`./configure` 还有 3 个不可替代的核心作用，也是它存在的意义：

- 系统环境兼容性检测：自动适配不同 Linux 发行版（CentOS、Ubuntu、Debian）、不同硬件架构（x86_64、ARM）、不同编译器版本，避免在 A 系统能编译，在 B 系统编译失败
- 解析用户自定义参数：接收用户传入的参数，将这些需求融入 Makefile 中
- 输出可视化配置报告：执行完成后，会打印一份清晰的报告，告诉用户最终的编译配置

```shell
./configure [OPTION…]
```

:::: field-group

::: field name="OPTION" type="常用选项" optional

- `--prefix=/path`：指定软件安装的根目录，默认为 `/usr/local`
- `--sysconfdir=/path`：指定软件系统配置文件的安装目录，默认与 `--prefix` 相同
- `--bindir=/path`：指定可执行文件的安装目录，默认与 `--prefix` 相同
- `--libdir=/path`：指定库文件的安装目录，默认与 `--prefix` 相同
- `--enable-feature`：启用特定功能，如 `--enable-ssl` 启用 SSL 支持
- `--disable-feature`：禁用特定功能，如 `--disable-ipv6` 禁用 IPv6 支持
- `--with-package=/path`：指定依赖包的路径（如 `--with-openssl=/usr/local/openssl`）
- `--without-package`：禁用特定依赖包，如 `--without-ldap` 禁用 LDAP 依赖
:::
::::

除此之外，软件作者根据功能需求定义了一些专属参数，用于开启或关闭特定功能、指定依赖包路径等，执行 `./configure --help` 可以列出该软件所有支持的配置参数，这是查看参数最权威的方式。

---

在开发多文件项目（比如 C/C++ 项目）时，手动输入 `gcc` 编译命令会非常繁琐，且修改一个文件后重新编译所有文件会浪费大量时间。

`make` 的核心价值是：

- 自动化构建：读取 Makefile（构建规则文件）中的指令，自动执行编译、链接等操作
- 增量构建：仅重新编译修改过的文件及其依赖文件，大幅节省编译时间

```shell
make [OPTION…] [TARGET…]
```

:::: field-group

::: field name="OPTION" type="常用选项" optional

- `-B`：强制全量构建，忽略文件修改时间，禁用增量构建
- `-jN`：指定并发编译线程数，N 建议设为 CPU 核心数
- `-C DIR`：先切换到指定目录再执行 `make`，无需手动 `cd`
- `-d`：打印极详细的调试信息，文件时间对比、依赖分析、执行命令等
- `-n`：干跑模式，只打印要执行的命令，不实际运行
- `-s`：静默模式，不输出任何信息，只显示错误信息
:::

::: field name="TARGET" type="目标规则" required default="all"
指定 `make` 执行什么任务（比如安装程序、清理文件）：

- `all`：编译所有必要的二进制程序、库文件等，是 Makefile 默认目标
- `install`：依赖 `all` 目标（先编译再安装），将编译好的程序、配置、库文件等复制到系统标准路径
- `clean`：删除编译过程生成的临时文件（如 `.o` 目标文件、可执行文件），保留 `./configure` 生成的 Makefile 和配置文件
- `distclean`：比 `clean` 更彻底，除清理编译产物外，还删除 `./configure` 生成的 Makefile、配置缓存、自动生成的脚本等
- `check`/`test`：运行软件自带的测试套件，验证编译后的程序功能是否正常
- `maintainer-clean`：极端彻底的清理，额外删除维护者生成的文件（如文档、自动生成的构建脚本）
:::

::::

## 编译安装 SSH

SSH（Secure Shell）是一种加密的网络协议，核心用途是实现对远程服务器的安全登录与管理，替代明文传输的 Telnet 协议，从根本上保障远程操作的数据安全性（如密码、指令传输加密），是服务器运维中不可或缺的基础工具。

OpenSSH 则是 SSH 协议的开源实现，也是主流 Linux 发行版默认预装的远程管理组件，包含 `sshd`（服务端，提供远程连接服务）、`ssh`（客户端，发起远程连接）、`scp`/`sftp`（文件传输工具）等核心程序，是服务器对外提供远程访问能力的核心载体。

由于 OpenSSH 涉及服务器安全边界，其漏洞修复与版本更新极为关键。一旦出现远程代码执行、权限绕过等漏洞，可能直接导致服务器被非法入侵。官方通常仅发布 OpenSSH 源码包（无预编译的 RPM 包），需要通过源码编译安装。

::: steps

1. 备份 SSH 配置文件

    ```bash
    openssh -V
    ```

    ```console
    OpenSSH_8.9p1, OpenSSL 3.1.1 1 Aug 2023
    ```

    为避免安装失败导致SSH服务中断，需提前备份现有sshd二进制文件、配置文件及服务管理单元，建议创建带时间戳的备份目录，便于追溯回滚：

    ```bash
    mkdir ssh_back.$(date +%Y%m%d)
    ```

    - `$(date +%Y%m%d)`：这是 shell 的命令替换，会先执行括号内的 `date` 命令，把输出结果作为字符串拼接到目录名中：

    ```bash
    cp /usr/sbin/sshd ~/ssh_back.20260128/
    cp /usr/lib/systemd/system/sshd.service ~/ssh_back.20260128/
    cp -r /etc/ssh ~/ssh_back.20260128/
    ```

    - `/usr/sbin/sshd`：sshd服务端二进制文件
    - `/usr/lib/systemd/system/sshd.service`：`systemd` 服务配置
    - `/etc/ssh`：完整SSH配置目录（含密钥、配置文件）

    ```bash
    ll ~/ssh_back.20260128/
    ```

    ```console
    total 396
    drwxr-xr-x. 4 root root   4096 Jan 28 14:07 ssh
    -rwxr-xr-x. 1 root root 396384 Jan 28 14:06 sshd
    -rw-r--r--. 1 root root    555 Jan 28 14:06 sshd.service
    ```

2. 安装依赖

    OpenSSH 基于 C 语言开发，编译需依赖编译器、压缩库、加密库、认证框架及安全策略适配库，缺失依赖会导致编译失败或功能异常：

    ```bash
    dnf -y install tar wget gcc make zlib-devel openssl-devel pam-devel libselinux-devel
    ```

    - `tar`/`wget`：基础工具，分别用于解压源码包、从网络下载源码（优先国内镜像，提升速度）
    - `gcc`：C语言编译器，核心工具，负责将 OpenSSH 源码编译为可执行二进制文件
    - `make`：构建自动化工具，解析源码中的 Makefile 编译规则，批量执行编译、链接步骤，避免手动输入复杂编译命令
    - `zlib-devel`：数据压缩库开发包，含编译所需头文件（`.h`）和库文件（`.so`），OpenSSH依赖其实现传输数据压缩，减少网络带宽占用
    - `openssl-devel`：加密库开发包，提供 SSH 核心加密算法（AES、RSA、SHA等），无此依赖则 `sshd` 无法实现加密通信，失去 SSH 核心安全能力
    - `pam-devel`：Linux统一认证框架（PAM）开发包，使 `sshd` 对接系统原生用户认证（如验证 `root`/普通用户密码），无此依赖则 SSH 无法识别系统用户
    - `libselinux-devel`：SELinux 安全策略适配库，确保编译后的 `sshd` 能兼容系统 SELINUX 规则，避免被拦截导致权限拒绝错误

3. 获取最新源码

    优先选择国内镜像源（阿里云）下载，避免外网连接不稳定导致源码包损坏：

    ```bash
    wget https://mirrors.aliyun.com/pub/OpenBSD/OpenSSH/portable/openssh-10.2p1.tar.gz
    tar -zxvf openssh-10.2p1.tar.gz
    cd openssh-10.2p1
    ```

4. 配置构建

    通过 `./configure` 命令检测系统环境、指定安装路径与功能开关，最终生成编译所需的 Makefile 文件：

    ```shell
    [root@localhost openssh-10.2p1]# ./configure \
    --prefix=/usr \
    --sysconfdir=/etc/ssh \
    --with-pam \
    --with-selinux \
    --with-zlib
    ```

   - `--prefix=/usr`：安装根路径，覆盖系统默认 `/usr/local`，直接替换系统原有 `sshd`
   - `--sysconfdir=/etc/ssh`：配置文件目录，与系统默认一致，保证配置兼容
   - `--with-pam`：启用 PAM 认证，对接系统用户密码验证
   - `--with-selinux`：启用 SELINUX 适配，避免权限拦截
   - `--with-zlib`：启用 zlib 数据压缩功能

    执行完 `./configure` 后，无任何 `error` 提示即为成功。

5. 编译并安装

    通过 `make` 编译源码，`make install` 安装编译后的文件，覆盖系统原有 `sshd` 组件：

    ```shell
    [root@localhost openssh-10.2p1]# make 
    [root@localhost openssh-10.2p1]# make install
    ```

    安装过程出现：

    - `/etc/ssh/ssh_config already exists, install will not overwrite`
    - `/etc/ssh/sshd_config already exists, install will not overwrite`
    - `/etc/ssh/moduli already exists, install will not overwrite`

    该提示表示安装程序不覆盖已存在的配置文件，避免丢失自定义配置（如端口、登录权限等），无需干预。

6. GSSAPI 问题

    执行 `make install` 后，系统会自动校验 `sshd` 配置，出现如下报错：

    ```log
    /usr/sbin/sshd -t -f /etc/ssh/sshd_config
    /etc/crypto-policies/back-ends/opensshserver.config: line 3: Bad configuration option: GSSAPIKexAlgorithms
    /etc/crypto-policies/back-ends/opensshserver.config: terminating, 1 bad configuration options
    make: [Makefile:420: check-config] Error 255 (ignored)
    ```

    `/usr/sbin/sshd -t -f /etc/ssh/sshd_config` 是 SSH 服务端配置校验命令，核心作用是在不启动 `sshd` 服务的前提下检测配置文件语法合法性与兼容性，避免因配置错误导致服务启动失败，是运维中排查 sshd 配置问题的关键步骤。

    报错中的 GSSAPIKexAlgorithms 是 GSSAPI 密钥交换（Key Exchange） 专用配置项，由系统 `crypto-policies` 自动生成并写入 `/etc/crypto-policies/back-ends/opensshserver.config`。

    > [!NOTE]GSSAPI
    > GSSAPI 是一套标准化的安全认证抽象框架，并非具体加密算法或单一协议。GSSAPI 作为中间抽象接口，核心作用是屏蔽底层不同安全机制（如 Kerberos、SPNEGO、NTLM）的实现差异。应用程序（sshd、Nginx、Samba 等）只需调用统一的 GSSAPI 接口，即可实现身份认证、密钥协商、数据加密，无需适配底层具体协议。Linux 系统中，GSSAPI 几乎均基于 Kerberos 5 协议实现，是企业级统一身份认证的核心组件。

    即便是安装了 `krb5-devel` 依赖，编译时加上 `--with-kerberos5` 选项，仍会出现此报错。可能是因为 OpenSSH 编译时检测到 Kerberos 库缺失实验性 API，主动禁用了 GSSAPI 密钥交换支持（安全设计），而系统 `crypto-policies` 仍生成含该指令的配置，导致冲突。

    可以注释掉 `/etc/ssh/sshd_config.d/40-redhat-crypto-policies.conf` 文件中引入 `crypto-policies` 配置的 Include 行，避免 `sshd` 校验时加载无效配置：

    ```bash
    sed -i 's|^Include /etc/crypto-policies/back-ends/opensshserver.config|#&|' /etc/ssh/sshd_config.d/40-redhat-crypto-policies.conf
    ```

7. 测试与验证

    安装完成后，可以再次通过 `sshd -V` 命令检查编译安装是否成功：

    ```bash
    sshd -V
    ```

    ```console
    OpenSSH_10.2p1, OpenSSL 3.5.1 1 Jul 2025
    ```

    重启 `sshd` 并验证状态：

    ```bash
    systemctl restart sshd
    systemctl status sshd
    ```

    >[!WARNING]
    > 升级全程 **请勿关闭当前操作终端**（即便出现 `sshd` 服务启动失败的报错，也不要关闭）。
    >
    > 如果在升级过程中关闭了当前操作终端，而新安装的 SSH 服务又启动失败，就会导致无法通过新终端重新连接服务器，相当于把自己锁在服务器外面，只能通过机房物理操作或云服务器控制台（VNC）恢复，非常麻烦。
    >
    > 而保留当前终端，即便 `sshd` 服务停止运行，当前已建立的 SSH 连接不会立即断开（TCP 连接未主动关闭），依然可以在这个终端里执行修复命令，相当于给自己留了一条后路，这是远程升级 SSH 的必备操作准则。
:::

## 源码编译卸载

编译安装的软件通常不会分散到系统的多个目录中。在编译安装过程中，通过 `--prefix` 参数可以指定一个安装前缀，软件及其所有相关核心文件（包括可执行文件、库文件、默认配置模板等），都会被统一安装到这个前缀指定的目录下。因此，卸载这类软件的核心方式，就是直接删除该安装目录。

例如，如果使用 `--prefix=/usr/local/nginx` 编译安装 Nginx，那么所有核心相关文件都会被安装到 `/usr/local/nginx` 目录下。卸载时，可先停止对应服务（避免文件被占用无法删除），再删除该目录：

```bash
rm -rf /usr/local/nginx
```

> [!WARNING]
> 即使软件的所有文件都被安装到一个目录下，也可能有配置文件和日志文件被创建在其他位置（如 `/etc` 和 `/var` 目录）。在卸载软件时，需要手动检查并删除这些文件。
